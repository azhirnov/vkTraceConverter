// auto-generated file

static void UnpackStruct (VkBaseOutStructure *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceSparseProperties (VkPhysicalDeviceSparseProperties *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorUpdateTemplateEntry (VkDescriptorUpdateTemplateEntry *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceLimits (VkPhysicalDeviceLimits *, vktrace_trace_packet_header *);
static void Unpack_VkImageFormatProperties (VkImageFormatProperties *, vktrace_trace_packet_header *);
static void Unpack_VkFormatProperties (VkFormatProperties *, vktrace_trace_packet_header *);
static void Unpack_VkPipelineColorBlendAttachmentState (VkPipelineColorBlendAttachmentState *, vktrace_trace_packet_header *);
static void Unpack_VkAllocationCallbacks (VkAllocationCallbacks *, vktrace_trace_packet_header *);
static void Unpack_VkSubresourceLayout (VkSubresourceLayout *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceFeatures (VkPhysicalDeviceFeatures *, vktrace_trace_packet_header *);
static void Unpack_VkExtent3D (VkExtent3D *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceProperties (VkPhysicalDeviceProperties *, vktrace_trace_packet_header *);
static void Unpack_VkSparseBufferMemoryBindInfo (VkSparseBufferMemoryBindInfo *, vktrace_trace_packet_header *);
static void Unpack_VkQueueFamilyProperties (VkQueueFamilyProperties *, vktrace_trace_packet_header *);
static void Unpack_VkMemoryType (VkMemoryType *, vktrace_trace_packet_header *);
static void Unpack_VkMemoryHeap (VkMemoryHeap *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceMemoryProperties (VkPhysicalDeviceMemoryProperties *, vktrace_trace_packet_header *);
static void Unpack_VkOffset2D (VkOffset2D *, vktrace_trace_packet_header *);
static void Unpack_VkSparseMemoryBind (VkSparseMemoryBind *, vktrace_trace_packet_header *);
static void Unpack_VkExtensionProperties (VkExtensionProperties *, vktrace_trace_packet_header *);
static void Unpack_VkLayerProperties (VkLayerProperties *, vktrace_trace_packet_header *);
static void Unpack_VkSpecializationMapEntry (VkSpecializationMapEntry *, vktrace_trace_packet_header *);
static void Unpack_VkComponentMapping (VkComponentMapping *, vktrace_trace_packet_header *);
static void Unpack_VkMemoryRequirements (VkMemoryRequirements *, vktrace_trace_packet_header *);
static void Unpack_VkImageResolve (VkImageResolve *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageFormatProperties (VkSparseImageFormatProperties *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageMemoryRequirements (VkSparseImageMemoryRequirements *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageOpaqueMemoryBindInfo (VkSparseImageOpaqueMemoryBindInfo *, vktrace_trace_packet_header *);
static void Unpack_VkImageSubresource (VkImageSubresource *, vktrace_trace_packet_header *);
static void Unpack_VkOffset3D (VkOffset3D *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageMemoryBind (VkSparseImageMemoryBind *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageMemoryBindInfo (VkSparseImageMemoryBindInfo *, vktrace_trace_packet_header *);
static void Unpack_VkViewport (VkViewport *, vktrace_trace_packet_header *);
static void Unpack_VkImageSubresourceRange (VkImageSubresourceRange *, vktrace_trace_packet_header *);
static void Unpack_VkSpecializationInfo (VkSpecializationInfo *, vktrace_trace_packet_header *);
static void Unpack_VkVertexInputBindingDescription (VkVertexInputBindingDescription *, vktrace_trace_packet_header *);
static void Unpack_VkImageCopy (VkImageCopy *, vktrace_trace_packet_header *);
static void Unpack_VkVertexInputAttributeDescription (VkVertexInputAttributeDescription *, vktrace_trace_packet_header *);
static void Unpack_VkExtent2D (VkExtent2D *, vktrace_trace_packet_header *);
static void Unpack_VkRect2D (VkRect2D *, vktrace_trace_packet_header *);
static void Unpack_VkStencilOpState (VkStencilOpState *, vktrace_trace_packet_header *);
static void Unpack_VkXYColorEXT (VkXYColorEXT *, vktrace_trace_packet_header *);
static void Unpack_VkPushConstantRange (VkPushConstantRange *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayPlanePropertiesKHR (VkDisplayPlanePropertiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorSetLayoutBinding (VkDescriptorSetLayoutBinding *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorPoolSize (VkDescriptorPoolSize *, vktrace_trace_packet_header *);
static void Unpack_VkClearValue (VkClearValue *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorImageInfo (VkDescriptorImageInfo *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorBufferInfo (VkDescriptorBufferInfo *, vktrace_trace_packet_header *);
static void Unpack_VkAttachmentDescription (VkAttachmentDescription *, vktrace_trace_packet_header *);
static void Unpack_VkAttachmentReference (VkAttachmentReference *, vktrace_trace_packet_header *);
static void Unpack_VkSubpassDescription (VkSubpassDescription *, vktrace_trace_packet_header *);
static void Unpack_VkSubpassDependency (VkSubpassDependency *, vktrace_trace_packet_header *);
static void Unpack_VkBufferCopy (VkBufferCopy *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayModePropertiesKHR (VkDisplayModePropertiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkImageSubresourceLayers (VkImageSubresourceLayers *, vktrace_trace_packet_header *);
static void Unpack_VkImageBlit (VkImageBlit *, vktrace_trace_packet_header *);
static void Unpack_VkBufferImageCopy (VkBufferImageCopy *, vktrace_trace_packet_header *);
static void Unpack_VkClearColorValue (VkClearColorValue *, vktrace_trace_packet_header *);
static void Unpack_VkClearDepthStencilValue (VkClearDepthStencilValue *, vktrace_trace_packet_header *);
static void Unpack_VkClearAttachment (VkClearAttachment *, vktrace_trace_packet_header *);
static void Unpack_VkClearRect (VkClearRect *, vktrace_trace_packet_header *);
static void Unpack_VkViewportSwizzleNV (VkViewportSwizzleNV *, vktrace_trace_packet_header *);
static void Unpack_VkInputAttachmentAspectReference (VkInputAttachmentAspectReference *, vktrace_trace_packet_header *);
static void Unpack_VkExternalMemoryProperties (VkExternalMemoryProperties *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayModeParametersKHR (VkDisplayModeParametersKHR *, vktrace_trace_packet_header *);
static void Unpack_VkSurfaceCapabilitiesKHR (VkSurfaceCapabilitiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkSurfaceFormatKHR (VkSurfaceFormatKHR *, vktrace_trace_packet_header *);
static void Unpack_VkExternalImageFormatPropertiesNV (VkExternalImageFormatPropertiesNV *, vktrace_trace_packet_header *);
static void Unpack_VkIndirectCommandsLayoutTokenNVX (VkIndirectCommandsLayoutTokenNVX *, vktrace_trace_packet_header *);
static void Unpack_VkVertexInputBindingDivisorDescriptionEXT (VkVertexInputBindingDivisorDescriptionEXT *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayPropertiesKHR (VkDisplayPropertiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayPlaneCapabilitiesKHR (VkDisplayPlaneCapabilitiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkSubpassSampleLocationsEXT (VkSubpassSampleLocationsEXT *, vktrace_trace_packet_header *);
static void Unpack_VkRectLayerKHR (VkRectLayerKHR *, vktrace_trace_packet_header *);
static void Unpack_VkPresentRegionKHR (VkPresentRegionKHR *, vktrace_trace_packet_header *);
static void Unpack_VkIndirectCommandsTokenNVX (VkIndirectCommandsTokenNVX *, vktrace_trace_packet_header *);
static void Unpack_VkObjectTableEntryNVX (VkObjectTableEntryNVX *, vktrace_trace_packet_header *);
static void Unpack_VkViewportWScalingNV (VkViewportWScalingNV *, vktrace_trace_packet_header *);
static void Unpack_VkRefreshCycleDurationGOOGLE (VkRefreshCycleDurationGOOGLE *, vktrace_trace_packet_header *);
static void Unpack_VkPastPresentationTimingGOOGLE (VkPastPresentationTimingGOOGLE *, vktrace_trace_packet_header *);
static void Unpack_VkPresentTimeGOOGLE (VkPresentTimeGOOGLE *, vktrace_trace_packet_header *);
static void Unpack_VkSampleLocationEXT (VkSampleLocationEXT *, vktrace_trace_packet_header *);
static void Unpack_VkAttachmentSampleLocationsEXT (VkAttachmentSampleLocationsEXT *, vktrace_trace_packet_header *);
//-----------------------------------------------------------------------------

static void UnpackStruct (VkBaseOutStructure *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pNext, header );
	UnpackStruct( PtrCast<VkBaseOutStructure>(ptr->pNext), header );

	ENABLE_ENUM_CHECKS();
	switch ( ptr->sType )
	{
		case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO : {
			VkDeviceCreateInfo*  value = BitCast<VkDeviceCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pQueueCreateInfos, header );
			for (uint i = 0; (value->pQueueCreateInfos != null) and (i < value->queueCreateInfoCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pQueueCreateInfos + i), header );
			}
			UnpackPointer( INOUT value->ppEnabledLayerNames, header );
			for (uint i = 0; (value->ppEnabledLayerNames != null) and (i < value->enabledLayerCount); ++i) {
				UnpackPointer( INOUT value->ppEnabledLayerNames[i], header );
			}
			UnpackPointer( INOUT value->ppEnabledExtensionNames, header );
			for (uint i = 0; (value->ppEnabledExtensionNames != null) and (i < value->enabledExtensionCount); ++i) {
				UnpackPointer( INOUT value->ppEnabledExtensionNames[i], header );
			}
			UnpackPointer( INOUT value->pEnabledFeatures, header );
			Unpack_VkPhysicalDeviceFeatures( PtrCast<VkPhysicalDeviceFeatures>(value->pEnabledFeatures), header );
			break;
		}

		case VK_STRUCTURE_TYPE_APPLICATION_INFO : {
			VkApplicationInfo*  value = BitCast<VkApplicationInfo*>( ptr );
			UnpackPointer( INOUT value->pApplicationName, header );
			UnpackPointer( INOUT value->pEngineName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT : {
			VkDebugUtilsObjectNameInfoEXT*  value = BitCast<VkDebugUtilsObjectNameInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pObjectName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO : {
			VkInstanceCreateInfo*  value = BitCast<VkInstanceCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pApplicationInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pApplicationInfo), header );
			UnpackPointer( INOUT value->ppEnabledLayerNames, header );
			for (uint i = 0; (value->ppEnabledLayerNames != null) and (i < value->enabledLayerCount); ++i) {
				UnpackPointer( INOUT value->ppEnabledLayerNames[i], header );
			}
			UnpackPointer( INOUT value->ppEnabledExtensionNames, header );
			for (uint i = 0; (value->ppEnabledExtensionNames != null) and (i < value->enabledExtensionCount); ++i) {
				UnpackPointer( INOUT value->ppEnabledExtensionNames[i], header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT : {
			VkValidationCacheCreateInfoEXT*  value = BitCast<VkValidationCacheCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pInitialData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR : {
			VkImageFormatListCreateInfoKHR*  value = BitCast<VkImageFormatListCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pViewFormats, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO : {
			VkDeviceQueueCreateInfo*  value = BitCast<VkDeviceQueueCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pQueuePriorities, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SUBMIT_INFO : {
			VkSubmitInfo*  value = BitCast<VkSubmitInfo*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphores, header );
			UnpackPointer( INOUT value->pWaitDstStageMask, header );
			UnpackPointer( INOUT value->pCommandBuffers, header );
			UnpackPointer( INOUT value->pSignalSemaphores, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO : {
			VkPipelineDynamicStateCreateInfo*  value = BitCast<VkPipelineDynamicStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pDynamicStates, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT : {
			VkImportMemoryHostPointerInfoEXT*  value = BitCast<VkImportMemoryHostPointerInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pHostPointer, header );
			break;
		}

		case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO : {
			VkBindSparseInfo*  value = BitCast<VkBindSparseInfo*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphores, header );
			UnpackPointer( INOUT value->pBufferBinds, header );
			for (uint i = 0; (value->pBufferBinds != null) and (i < value->bufferBindCount); ++i) {
				Unpack_VkSparseBufferMemoryBindInfo( PtrCast<VkSparseBufferMemoryBindInfo>(value->pBufferBinds + i), header );
			}
			UnpackPointer( INOUT value->pImageOpaqueBinds, header );
			for (uint i = 0; (value->pImageOpaqueBinds != null) and (i < value->imageOpaqueBindCount); ++i) {
				Unpack_VkSparseImageOpaqueMemoryBindInfo( PtrCast<VkSparseImageOpaqueMemoryBindInfo>(value->pImageOpaqueBinds + i), header );
			}
			UnpackPointer( INOUT value->pImageBinds, header );
			for (uint i = 0; (value->pImageBinds != null) and (i < value->imageBindCount); ++i) {
				Unpack_VkSparseImageMemoryBindInfo( PtrCast<VkSparseImageMemoryBindInfo>(value->pImageBinds + i), header );
			}
			UnpackPointer( INOUT value->pSignalSemaphores, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO : {
			VkPipelineViewportStateCreateInfo*  value = BitCast<VkPipelineViewportStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pViewports, header );
			for (uint i = 0; (value->pViewports != null) and (i < value->viewportCount); ++i) {
				Unpack_VkViewport( PtrCast<VkViewport>(value->pViewports + i), header );
			}
			UnpackPointer( INOUT value->pScissors, header );
			for (uint i = 0; (value->pScissors != null) and (i < value->scissorCount); ++i) {
				Unpack_VkRect2D( PtrCast<VkRect2D>(value->pScissors + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO : {
			VkPipelineVertexInputStateCreateInfo*  value = BitCast<VkPipelineVertexInputStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pVertexBindingDescriptions, header );
			for (uint i = 0; (value->pVertexBindingDescriptions != null) and (i < value->vertexBindingDescriptionCount); ++i) {
				Unpack_VkVertexInputBindingDescription( PtrCast<VkVertexInputBindingDescription>(value->pVertexBindingDescriptions + i), header );
			}
			UnpackPointer( INOUT value->pVertexAttributeDescriptions, header );
			for (uint i = 0; (value->pVertexAttributeDescriptions != null) and (i < value->vertexAttributeDescriptionCount); ++i) {
				Unpack_VkVertexInputAttributeDescription( PtrCast<VkVertexInputAttributeDescription>(value->pVertexAttributeDescriptions + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkExportSemaphoreWin32HandleInfoKHR*  value = BitCast<VkExportSemaphoreWin32HandleInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pAttributes, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO : {
			VkRenderPassBeginInfo*  value = BitCast<VkRenderPassBeginInfo*>( ptr );
			UnpackPointer( INOUT value->pClearValues, header );
			for (uint i = 0; (value->pClearValues != null) and (i < value->clearValueCount); ++i) {
				Unpack_VkClearValue( PtrCast<VkClearValue>(value->pClearValues + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO : {
			VkBufferCreateInfo*  value = BitCast<VkBufferCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pQueueFamilyIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO : {
			VkImageCreateInfo*  value = BitCast<VkImageCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pQueueFamilyIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO : {
			VkPipelineMultisampleStateCreateInfo*  value = BitCast<VkPipelineMultisampleStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pSampleMask, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO : {
			VkShaderModuleCreateInfo*  value = BitCast<VkShaderModuleCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pCode, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT : {
			VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*  value = BitCast<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pBindingFlags, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO : {
			VkPipelineCacheCreateInfo*  value = BitCast<VkPipelineCacheCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pInitialData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO : {
			VkPipelineShaderStageCreateInfo*  value = BitCast<VkPipelineShaderStageCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pName, header );
			UnpackPointer( INOUT value->pSpecializationInfo, header );
			Unpack_VkSpecializationInfo( PtrCast<VkSpecializationInfo>(value->pSpecializationInfo), header );
			break;
		}

		case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE : {
			VkPresentTimesInfoGOOGLE*  value = BitCast<VkPresentTimesInfoGOOGLE*>( ptr );
			UnpackPointer( INOUT value->pTimes, header );
			for (uint i = 0; (value->pTimes != null) and (i < value->swapchainCount); ++i) {
				Unpack_VkPresentTimeGOOGLE( PtrCast<VkPresentTimeGOOGLE>(value->pTimes + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR : {
			#ifdef VULKAN_ANDROID_H_
			VkAndroidSurfaceCreateInfoKHR*  value = BitCast<VkAndroidSurfaceCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->window, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO : {
			VkPipelineColorBlendStateCreateInfo*  value = BitCast<VkPipelineColorBlendStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pAttachments, header );
			for (uint i = 0; (value->pAttachments != null) and (i < value->attachmentCount); ++i) {
				Unpack_VkPipelineColorBlendAttachmentState( PtrCast<VkPipelineColorBlendAttachmentState>(value->pAttachments + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO : {
			VkGraphicsPipelineCreateInfo*  value = BitCast<VkGraphicsPipelineCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pStages, header );
			for (uint i = 0; (value->pStages != null) and (i < value->stageCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pStages + i), header );
			}
			UnpackPointer( INOUT value->pVertexInputState, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pVertexInputState), header );
			UnpackPointer( INOUT value->pInputAssemblyState, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pInputAssemblyState), header );
			UnpackPointer( INOUT value->pTessellationState, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pTessellationState), header );
			UnpackPointer( INOUT value->pViewportState, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pViewportState), header );
			UnpackPointer( INOUT value->pRasterizationState, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pRasterizationState), header );
			UnpackPointer( INOUT value->pMultisampleState, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pMultisampleState), header );
			UnpackPointer( INOUT value->pDepthStencilState, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pDepthStencilState), header );
			UnpackPointer( INOUT value->pColorBlendState, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pColorBlendState), header );
			UnpackPointer( INOUT value->pDynamicState, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pDynamicState), header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO : {
			VkPipelineLayoutCreateInfo*  value = BitCast<VkPipelineLayoutCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pSetLayouts, header );
			UnpackPointer( INOUT value->pPushConstantRanges, header );
			for (uint i = 0; (value->pPushConstantRanges != null) and (i < value->pushConstantRangeCount); ++i) {
				Unpack_VkPushConstantRange( PtrCast<VkPushConstantRange>(value->pPushConstantRanges + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO : {
			VkDescriptorSetLayoutCreateInfo*  value = BitCast<VkDescriptorSetLayoutCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pBindings, header );
			for (uint i = 0; (value->pBindings != null) and (i < value->bindingCount); ++i) {
				Unpack_VkDescriptorSetLayoutBinding( PtrCast<VkDescriptorSetLayoutBinding>(value->pBindings + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO : {
			VkDescriptorPoolCreateInfo*  value = BitCast<VkDescriptorPoolCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pPoolSizes, header );
			for (uint i = 0; (value->pPoolSizes != null) and (i < value->poolSizeCount); ++i) {
				Unpack_VkDescriptorPoolSize( PtrCast<VkDescriptorPoolSize>(value->pPoolSizes + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO : {
			VkDescriptorSetAllocateInfo*  value = BitCast<VkDescriptorSetAllocateInfo*>( ptr );
			UnpackPointer( INOUT value->pSetLayouts, header );
			break;
		}

		case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV : {
			#ifdef VULKAN_WIN32_H_
			VkExportMemoryWin32HandleInfoNV*  value = BitCast<VkExportMemoryWin32HandleInfoNV*>( ptr );
			UnpackPointer( INOUT value->pAttributes, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET : {
			VkWriteDescriptorSet*  value = BitCast<VkWriteDescriptorSet*>( ptr );
			UnpackPointer( INOUT value->pImageInfo, header );
			for (uint i = 0; (value->pImageInfo != null) and (i < value->descriptorCount); ++i) {
				Unpack_VkDescriptorImageInfo( PtrCast<VkDescriptorImageInfo>(value->pImageInfo + i), header );
			}
			UnpackPointer( INOUT value->pBufferInfo, header );
			for (uint i = 0; (value->pBufferInfo != null) and (i < value->descriptorCount); ++i) {
				Unpack_VkDescriptorBufferInfo( PtrCast<VkDescriptorBufferInfo>(value->pBufferInfo + i), header );
			}
			UnpackPointer( INOUT value->pTexelBufferView, header );
			break;
		}

		case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO : {
			VkFramebufferCreateInfo*  value = BitCast<VkFramebufferCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pAttachments, header );
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO : {
			VkRenderPassCreateInfo*  value = BitCast<VkRenderPassCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pAttachments, header );
			for (uint i = 0; (value->pAttachments != null) and (i < value->attachmentCount); ++i) {
				Unpack_VkAttachmentDescription( PtrCast<VkAttachmentDescription>(value->pAttachments + i), header );
			}
			UnpackPointer( INOUT value->pSubpasses, header );
			for (uint i = 0; (value->pSubpasses != null) and (i < value->subpassCount); ++i) {
				Unpack_VkSubpassDescription( PtrCast<VkSubpassDescription>(value->pSubpasses + i), header );
			}
			UnpackPointer( INOUT value->pDependencies, header );
			for (uint i = 0; (value->pDependencies != null) and (i < value->dependencyCount); ++i) {
				Unpack_VkSubpassDependency( PtrCast<VkSubpassDependency>(value->pDependencies + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO : {
			VkCommandBufferBeginInfo*  value = BitCast<VkCommandBufferBeginInfo*>( ptr );
			UnpackPointer( INOUT value->pInheritanceInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pInheritanceInfo), header );
			break;
		}

		case VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR : {
			#ifdef VULKAN_MIR_H_
			VkMirSurfaceCreateInfoKHR*  value = BitCast<VkMirSurfaceCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->connection, header );
			UnpackPointer( INOUT value->mirSurface, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO : {
			VkDeviceGroupRenderPassBeginInfo*  value = BitCast<VkDeviceGroupRenderPassBeginInfo*>( ptr );
			UnpackPointer( INOUT value->pDeviceRenderAreas, header );
			for (uint i = 0; (value->pDeviceRenderAreas != null) and (i < value->deviceRenderAreaCount); ++i) {
				Unpack_VkRect2D( PtrCast<VkRect2D>(value->pDeviceRenderAreas + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO : {
			VkDeviceGroupSubmitInfo*  value = BitCast<VkDeviceGroupSubmitInfo*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphoreDeviceIndices, header );
			UnpackPointer( INOUT value->pCommandBufferDeviceMasks, header );
			UnpackPointer( INOUT value->pSignalSemaphoreDeviceIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO : {
			VkBindBufferMemoryDeviceGroupInfo*  value = BitCast<VkBindBufferMemoryDeviceGroupInfo*>( ptr );
			UnpackPointer( INOUT value->pDeviceIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO : {
			VkBindImageMemoryDeviceGroupInfo*  value = BitCast<VkBindImageMemoryDeviceGroupInfo*>( ptr );
			UnpackPointer( INOUT value->pDeviceIndices, header );
			UnpackPointer( INOUT value->pSplitInstanceBindRegions, header );
			for (uint i = 0; (value->pSplitInstanceBindRegions != null) and (i < value->splitInstanceBindRegionCount); ++i) {
				Unpack_VkRect2D( PtrCast<VkRect2D>(value->pSplitInstanceBindRegions + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO : {
			VkDeviceGroupDeviceCreateInfo*  value = BitCast<VkDeviceGroupDeviceCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pPhysicalDevices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO : {
			VkRenderPassInputAttachmentAspectCreateInfo*  value = BitCast<VkRenderPassInputAttachmentAspectCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pAspectReferences, header );
			for (uint i = 0; (value->pAspectReferences != null) and (i < value->aspectReferenceCount); ++i) {
				Unpack_VkInputAttachmentAspectReference( PtrCast<VkInputAttachmentAspectReference>(value->pAspectReferences + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO : {
			VkRenderPassMultiviewCreateInfo*  value = BitCast<VkRenderPassMultiviewCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pViewMasks, header );
			UnpackPointer( INOUT value->pViewOffsets, header );
			UnpackPointer( INOUT value->pCorrelationMasks, header );
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT : {
			VkRenderPassSampleLocationsBeginInfoEXT*  value = BitCast<VkRenderPassSampleLocationsBeginInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pAttachmentInitialSampleLocations, header );
			for (uint i = 0; (value->pAttachmentInitialSampleLocations != null) and (i < value->attachmentInitialSampleLocationsCount); ++i) {
				Unpack_VkAttachmentSampleLocationsEXT( PtrCast<VkAttachmentSampleLocationsEXT>(value->pAttachmentInitialSampleLocations + i), header );
			}
			UnpackPointer( INOUT value->pPostSubpassSampleLocations, header );
			for (uint i = 0; (value->pPostSubpassSampleLocations != null) and (i < value->postSubpassSampleLocationsCount); ++i) {
				Unpack_VkSubpassSampleLocationsEXT( PtrCast<VkSubpassSampleLocationsEXT>(value->pPostSubpassSampleLocations + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO : {
			VkDescriptorUpdateTemplateCreateInfo*  value = BitCast<VkDescriptorUpdateTemplateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pDescriptorUpdateEntries, header );
			for (uint i = 0; (value->pDescriptorUpdateEntries != null) and (i < value->descriptorUpdateEntryCount); ++i) {
				Unpack_VkDescriptorUpdateTemplateEntry( PtrCast<VkDescriptorUpdateTemplateEntry>(value->pDescriptorUpdateEntries + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkExportMemoryWin32HandleInfoKHR*  value = BitCast<VkExportMemoryWin32HandleInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pAttributes, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR : {
			VkSwapchainCreateInfoKHR*  value = BitCast<VkSwapchainCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pQueueFamilyIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR : {
			VkPresentInfoKHR*  value = BitCast<VkPresentInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphores, header );
			UnpackPointer( INOUT value->pSwapchains, header );
			UnpackPointer( INOUT value->pImageIndices, header );
			UnpackPointer( INOUT value->pResults, header );
			break;
		}

		case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV : {
			#ifdef VULKAN_WIN32_H_
			VkWin32KeyedMutexAcquireReleaseInfoNV*  value = BitCast<VkWin32KeyedMutexAcquireReleaseInfoNV*>( ptr );
			UnpackPointer( INOUT value->pAcquireSyncs, header );
			UnpackPointer( INOUT value->pAcquireKeys, header );
			UnpackPointer( INOUT value->pAcquireTimeoutMilliseconds, header );
			UnpackPointer( INOUT value->pReleaseSyncs, header );
			UnpackPointer( INOUT value->pReleaseKeys, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR : {
			VkDeviceGroupPresentInfoKHR*  value = BitCast<VkDeviceGroupPresentInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pDeviceMasks, header );
			break;
		}

		case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR : {
			#ifdef VULKAN_XCB_H_
			VkXcbSurfaceCreateInfoKHR*  value = BitCast<VkXcbSurfaceCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->connection, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR : {
			VkPresentRegionsKHR*  value = BitCast<VkPresentRegionsKHR*>( ptr );
			UnpackPointer( INOUT value->pRegions, header );
			for (uint i = 0; (value->pRegions != null) and (i < value->swapchainCount); ++i) {
				Unpack_VkPresentRegionKHR( PtrCast<VkPresentRegionKHR>(value->pRegions + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR : {
			VkSubpassDescription2KHR*  value = BitCast<VkSubpassDescription2KHR*>( ptr );
			UnpackPointer( INOUT value->pInputAttachments, header );
			for (uint i = 0; (value->pInputAttachments != null) and (i < value->inputAttachmentCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pInputAttachments + i), header );
			}
			UnpackPointer( INOUT value->pColorAttachments, header );
			for (uint i = 0; (value->pColorAttachments != null) and (i < value->colorAttachmentCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pColorAttachments + i), header );
			}
			UnpackPointer( INOUT value->pResolveAttachments, header );
			for (uint i = 0; (value->pResolveAttachments != null) and (i < value->colorAttachmentCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pResolveAttachments + i), header );
			}
			UnpackPointer( INOUT value->pDepthStencilAttachment, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(value->pDepthStencilAttachment), header );
			UnpackPointer( INOUT value->pPreserveAttachments, header );
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR : {
			VkRenderPassCreateInfo2KHR*  value = BitCast<VkRenderPassCreateInfo2KHR*>( ptr );
			UnpackPointer( INOUT value->pAttachments, header );
			for (uint i = 0; (value->pAttachments != null) and (i < value->attachmentCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pAttachments + i), header );
			}
			UnpackPointer( INOUT value->pSubpasses, header );
			for (uint i = 0; (value->pSubpasses != null) and (i < value->subpassCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pSubpasses + i), header );
			}
			UnpackPointer( INOUT value->pDependencies, header );
			for (uint i = 0; (value->pDependencies != null) and (i < value->dependencyCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pDependencies + i), header );
			}
			UnpackPointer( INOUT value->pCorrelatedViewMasks, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT : {
			VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*  value = BitCast<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pDescriptorCounts, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT : {
			VkDebugReportCallbackCreateInfoEXT*  value = BitCast<VkDebugReportCallbackCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pUserData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT : {
			VkDebugMarkerObjectNameInfoEXT*  value = BitCast<VkDebugMarkerObjectNameInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pObjectName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT : {
			VkDebugMarkerObjectTagInfoEXT*  value = BitCast<VkDebugMarkerObjectTagInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pTag, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT : {
			VkDebugMarkerMarkerInfoEXT*  value = BitCast<VkDebugMarkerMarkerInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pMarkerName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT : {
			VkValidationFlagsEXT*  value = BitCast<VkValidationFlagsEXT*>( ptr );
			UnpackPointer( INOUT value->pDisabledValidationChecks, header );
			break;
		}

		case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkD3D12FenceSubmitInfoKHR*  value = BitCast<VkD3D12FenceSubmitInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphoreValues, header );
			UnpackPointer( INOUT value->pSignalSemaphoreValues, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX : {
			VkIndirectCommandsLayoutCreateInfoNVX*  value = BitCast<VkIndirectCommandsLayoutCreateInfoNVX*>( ptr );
			UnpackPointer( INOUT value->pTokens, header );
			for (uint i = 0; (value->pTokens != null) and (i < value->tokenCount); ++i) {
				Unpack_VkIndirectCommandsLayoutTokenNVX( PtrCast<VkIndirectCommandsLayoutTokenNVX>(value->pTokens + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX : {
			VkCmdProcessCommandsInfoNVX*  value = BitCast<VkCmdProcessCommandsInfoNVX*>( ptr );
			UnpackPointer( INOUT value->pIndirectCommandsTokens, header );
			for (uint i = 0; (value->pIndirectCommandsTokens != null) and (i < value->indirectCommandsTokenCount); ++i) {
				Unpack_VkIndirectCommandsTokenNVX( PtrCast<VkIndirectCommandsTokenNVX>(value->pIndirectCommandsTokens + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX : {
			VkObjectTableCreateInfoNVX*  value = BitCast<VkObjectTableCreateInfoNVX*>( ptr );
			UnpackPointer( INOUT value->pObjectEntryTypes, header );
			UnpackPointer( INOUT value->pObjectEntryCounts, header );
			UnpackPointer( INOUT value->pObjectEntryUsageFlags, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV : {
			VkPipelineViewportWScalingStateCreateInfoNV*  value = BitCast<VkPipelineViewportWScalingStateCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pViewportWScalings, header );
			for (uint i = 0; (value->pViewportWScalings != null) and (i < value->viewportCount); ++i) {
				Unpack_VkViewportWScalingNV( PtrCast<VkViewportWScalingNV>(value->pViewportWScalings + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV : {
			VkPipelineViewportSwizzleStateCreateInfoNV*  value = BitCast<VkPipelineViewportSwizzleStateCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pViewportSwizzles, header );
			for (uint i = 0; (value->pViewportSwizzles != null) and (i < value->viewportCount); ++i) {
				Unpack_VkViewportSwizzleNV( PtrCast<VkViewportSwizzleNV>(value->pViewportSwizzles + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT : {
			VkPipelineDiscardRectangleStateCreateInfoEXT*  value = BitCast<VkPipelineDiscardRectangleStateCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pDiscardRectangles, header );
			for (uint i = 0; (value->pDiscardRectangles != null) and (i < value->discardRectangleCount); ++i) {
				Unpack_VkRect2D( PtrCast<VkRect2D>(value->pDiscardRectangles + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT : {
			VkDebugUtilsObjectTagInfoEXT*  value = BitCast<VkDebugUtilsObjectTagInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pTag, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT : {
			VkDebugUtilsLabelEXT*  value = BitCast<VkDebugUtilsLabelEXT*>( ptr );
			UnpackPointer( INOUT value->pLabelName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT : {
			VkDebugUtilsMessengerCallbackDataEXT*  value = BitCast<VkDebugUtilsMessengerCallbackDataEXT*>( ptr );
			UnpackPointer( INOUT value->pMessageIdName, header );
			UnpackPointer( INOUT value->pMessage, header );
			UnpackPointer( INOUT value->pQueueLabels, header );
			for (uint i = 0; (value->pQueueLabels != null) and (i < value->queueLabelCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pQueueLabels + i), header );
			}
			UnpackPointer( INOUT value->pCmdBufLabels, header );
			for (uint i = 0; (value->pCmdBufLabels != null) and (i < value->cmdBufLabelCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pCmdBufLabels + i), header );
			}
			UnpackPointer( INOUT value->pObjects, header );
			for (uint i = 0; (value->pObjects != null) and (i < value->objectCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(value->pObjects + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT : {
			VkDebugUtilsMessengerCreateInfoEXT*  value = BitCast<VkDebugUtilsMessengerCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pUserData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT : {
			VkWriteDescriptorSetInlineUniformBlockEXT*  value = BitCast<VkWriteDescriptorSetInlineUniformBlockEXT*>( ptr );
			UnpackPointer( INOUT value->pData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT : {
			VkSampleLocationsInfoEXT*  value = BitCast<VkSampleLocationsInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pSampleLocations, header );
			for (uint i = 0; (value->pSampleLocations != null) and (i < value->sampleLocationsCount); ++i) {
				Unpack_VkSampleLocationEXT( PtrCast<VkSampleLocationEXT>(value->pSampleLocations + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV : {
			VkPipelineCoverageModulationStateCreateInfoNV*  value = BitCast<VkPipelineCoverageModulationStateCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pCoverageModulationTable, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT : {
			VkPipelineVertexInputDivisorStateCreateInfoEXT*  value = BitCast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pVertexBindingDivisors, header );
			for (uint i = 0; (value->pVertexBindingDivisors != null) and (i < value->vertexBindingDivisorCount); ++i) {
				Unpack_VkVertexInputBindingDivisorDescriptionEXT( PtrCast<VkVertexInputBindingDivisorDescriptionEXT>(value->pVertexBindingDivisors + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV : {
			VkCheckpointDataNV*  value = BitCast<VkCheckpointDataNV*>( ptr );
			UnpackPointer( INOUT value->pCheckpointMarker, header );
			break;
		}

		case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkWin32KeyedMutexAcquireReleaseInfoKHR*  value = BitCast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pAcquireSyncs, header );
			UnpackPointer( INOUT value->pAcquireKeys, header );
			UnpackPointer( INOUT value->pAcquireTimeouts, header );
			UnpackPointer( INOUT value->pReleaseSyncs, header );
			UnpackPointer( INOUT value->pReleaseKeys, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkExportFenceWin32HandleInfoKHR*  value = BitCast<VkExportFenceWin32HandleInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pAttributes, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID : {
			#ifdef VULKAN_ANDROID_H_
			VkImportAndroidHardwareBufferInfoANDROID*  value = BitCast<VkImportAndroidHardwareBufferInfoANDROID*>( ptr );
			UnpackPointer( INOUT value->buffer, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR : {
			#ifdef VULKAN_XLIB_H_
			VkXlibSurfaceCreateInfoKHR*  value = BitCast<VkXlibSurfaceCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->dpy, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR : {
			#ifdef VULKAN_WAYLAND_H_
			VkWaylandSurfaceCreateInfoKHR*  value = BitCast<VkWaylandSurfaceCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->display, header );
			UnpackPointer( INOUT value->surface, header );
			#endif
			break;
		}

	case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN : break;
	case VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK : break;
	case VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK : break;
	case VK_STRUCTURE_TYPE_RANGE_SIZE : break;
	case VK_STRUCTURE_TYPE_MAX_ENUM : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_MEMORY_BARRIER : break;
	case VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR : break;
	case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID : break;
	case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE : break;
	case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 : break;
	case VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR : break;
	case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO : break;
	case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX : break;
	case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO : break;
	case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO : break;
	case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR : break;
	case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 : break;
	case VK_STRUCTURE_TYPE_HDR_METADATA_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO : break;
	case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO : break;
	case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT : break;
	case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX : break;
	case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER : break;
	case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER : break;
	case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO : break;
	case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO : break;
	case VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES : break;
	case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS : break;
	case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO : break;
	case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO : break;
	case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO : break;
	case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 : break;
	case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 : break;
	case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR : break;
	case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 : break;
	case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT : break;
	case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 : break;
	case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES : break;
	case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 : break;
	case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 : break;
	case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES : break;
	case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES : break;
	case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 : break;
	case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO : break;
	case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO : break;
	case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES : break;
	case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR : break;
	case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR : break;
	case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR : break;
	case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR : break;
	case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR : break;
	case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV : break;
	case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR : break;
	case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT : break;
	case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR : break;
	case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR : break;
	case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR : break;
	case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR : break;
	case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR : break;
	case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR : break;
	case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD : break;
	case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID : break;
	case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT : break;
	case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX : break;
	case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX : break;
	case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID : break;
	case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID : break;
	}
	DISABLE_ENUM_CHECKS();
}
//-----------------------------------------------------------------------------

static void Unpack_VkPhysicalDeviceSparseProperties (VkPhysicalDeviceSparseProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDescriptorUpdateTemplateEntry (VkDescriptorUpdateTemplateEntry *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPhysicalDeviceLimits (VkPhysicalDeviceLimits *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageFormatProperties (VkImageFormatProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkFormatProperties (VkFormatProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPipelineColorBlendAttachmentState (VkPipelineColorBlendAttachmentState *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkAllocationCallbacks (VkAllocationCallbacks *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pUserData, header );
}

static void Unpack_VkSubresourceLayout (VkSubresourceLayout *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPhysicalDeviceFeatures (VkPhysicalDeviceFeatures *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExtent3D (VkExtent3D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPhysicalDeviceProperties (VkPhysicalDeviceProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSparseBufferMemoryBindInfo (VkSparseBufferMemoryBindInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pBinds, header );
	for (uint i = 0; (ptr->pBinds != null) and (i < ptr->bindCount); ++i) {
		Unpack_VkSparseMemoryBind( PtrCast<VkSparseMemoryBind>(ptr->pBinds + i), header );
	}
}

static void Unpack_VkQueueFamilyProperties (VkQueueFamilyProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkMemoryType (VkMemoryType *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkMemoryHeap (VkMemoryHeap *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPhysicalDeviceMemoryProperties (VkPhysicalDeviceMemoryProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkOffset2D (VkOffset2D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSparseMemoryBind (VkSparseMemoryBind *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExtensionProperties (VkExtensionProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkLayerProperties (VkLayerProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSpecializationMapEntry (VkSpecializationMapEntry *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkComponentMapping (VkComponentMapping *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkMemoryRequirements (VkMemoryRequirements *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageResolve (VkImageResolve *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSparseImageFormatProperties (VkSparseImageFormatProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSparseImageMemoryRequirements (VkSparseImageMemoryRequirements *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSparseImageOpaqueMemoryBindInfo (VkSparseImageOpaqueMemoryBindInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pBinds, header );
	for (uint i = 0; (ptr->pBinds != null) and (i < ptr->bindCount); ++i) {
		Unpack_VkSparseMemoryBind( PtrCast<VkSparseMemoryBind>(ptr->pBinds + i), header );
	}
}

static void Unpack_VkImageSubresource (VkImageSubresource *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkOffset3D (VkOffset3D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSparseImageMemoryBind (VkSparseImageMemoryBind *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSparseImageMemoryBindInfo (VkSparseImageMemoryBindInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pBinds, header );
	for (uint i = 0; (ptr->pBinds != null) and (i < ptr->bindCount); ++i) {
		Unpack_VkSparseImageMemoryBind( PtrCast<VkSparseImageMemoryBind>(ptr->pBinds + i), header );
	}
}

static void Unpack_VkViewport (VkViewport *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageSubresourceRange (VkImageSubresourceRange *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSpecializationInfo (VkSpecializationInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pMapEntries, header );
	for (uint i = 0; (ptr->pMapEntries != null) and (i < ptr->mapEntryCount); ++i) {
		Unpack_VkSpecializationMapEntry( PtrCast<VkSpecializationMapEntry>(ptr->pMapEntries + i), header );
	}
	UnpackPointer( INOUT ptr->pData, header );
}

static void Unpack_VkVertexInputBindingDescription (VkVertexInputBindingDescription *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageCopy (VkImageCopy *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkVertexInputAttributeDescription (VkVertexInputAttributeDescription *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExtent2D (VkExtent2D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkRect2D (VkRect2D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkStencilOpState (VkStencilOpState *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkXYColorEXT (VkXYColorEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPushConstantRange (VkPushConstantRange *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDisplayPlanePropertiesKHR (VkDisplayPlanePropertiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDescriptorSetLayoutBinding (VkDescriptorSetLayoutBinding *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pImmutableSamplers, header );
}

static void Unpack_VkDescriptorPoolSize (VkDescriptorPoolSize *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkClearValue (VkClearValue *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDescriptorImageInfo (VkDescriptorImageInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDescriptorBufferInfo (VkDescriptorBufferInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkAttachmentDescription (VkAttachmentDescription *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkAttachmentReference (VkAttachmentReference *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSubpassDescription (VkSubpassDescription *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pInputAttachments, header );
	for (uint i = 0; (ptr->pInputAttachments != null) and (i < ptr->inputAttachmentCount); ++i) {
		Unpack_VkAttachmentReference( PtrCast<VkAttachmentReference>(ptr->pInputAttachments + i), header );
	}
	UnpackPointer( INOUT ptr->pColorAttachments, header );
	for (uint i = 0; (ptr->pColorAttachments != null) and (i < ptr->colorAttachmentCount); ++i) {
		Unpack_VkAttachmentReference( PtrCast<VkAttachmentReference>(ptr->pColorAttachments + i), header );
	}
	UnpackPointer( INOUT ptr->pResolveAttachments, header );
	for (uint i = 0; (ptr->pResolveAttachments != null) and (i < ptr->colorAttachmentCount); ++i) {
		Unpack_VkAttachmentReference( PtrCast<VkAttachmentReference>(ptr->pResolveAttachments + i), header );
	}
	UnpackPointer( INOUT ptr->pDepthStencilAttachment, header );
	Unpack_VkAttachmentReference( PtrCast<VkAttachmentReference>(ptr->pDepthStencilAttachment), header );
	UnpackPointer( INOUT ptr->pPreserveAttachments, header );
}

static void Unpack_VkSubpassDependency (VkSubpassDependency *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkBufferCopy (VkBufferCopy *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDisplayModePropertiesKHR (VkDisplayModePropertiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageSubresourceLayers (VkImageSubresourceLayers *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageBlit (VkImageBlit *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkBufferImageCopy (VkBufferImageCopy *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkClearColorValue (VkClearColorValue *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkClearDepthStencilValue (VkClearDepthStencilValue *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkClearAttachment (VkClearAttachment *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkClearRect (VkClearRect *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkViewportSwizzleNV (VkViewportSwizzleNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkInputAttachmentAspectReference (VkInputAttachmentAspectReference *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExternalMemoryProperties (VkExternalMemoryProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDisplayModeParametersKHR (VkDisplayModeParametersKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSurfaceCapabilitiesKHR (VkSurfaceCapabilitiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSurfaceFormatKHR (VkSurfaceFormatKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExternalImageFormatPropertiesNV (VkExternalImageFormatPropertiesNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkIndirectCommandsLayoutTokenNVX (VkIndirectCommandsLayoutTokenNVX *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkVertexInputBindingDivisorDescriptionEXT (VkVertexInputBindingDivisorDescriptionEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDisplayPropertiesKHR (VkDisplayPropertiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->displayName, header );
}

static void Unpack_VkDisplayPlaneCapabilitiesKHR (VkDisplayPlaneCapabilitiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSubpassSampleLocationsEXT (VkSubpassSampleLocationsEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkRectLayerKHR (VkRectLayerKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPresentRegionKHR (VkPresentRegionKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pRectangles, header );
	for (uint i = 0; (ptr->pRectangles != null) and (i < ptr->rectangleCount); ++i) {
		Unpack_VkRectLayerKHR( PtrCast<VkRectLayerKHR>(ptr->pRectangles + i), header );
	}
}

static void Unpack_VkIndirectCommandsTokenNVX (VkIndirectCommandsTokenNVX *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkObjectTableEntryNVX (VkObjectTableEntryNVX *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkViewportWScalingNV (VkViewportWScalingNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkRefreshCycleDurationGOOGLE (VkRefreshCycleDurationGOOGLE *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPastPresentationTimingGOOGLE (VkPastPresentationTimingGOOGLE *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPresentTimeGOOGLE (VkPresentTimeGOOGLE *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSampleLocationEXT (VkSampleLocationEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkAttachmentSampleLocationsEXT (VkAttachmentSampleLocationsEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

//-----------------------------------------------------------------------------

static void UnpackPacket (vktrace_trace_packet_header *header)
{
	if ( not header ) return;
	ENABLE_ENUM_CHECKS();
	switch ( header->packet_id )
	{
		case VKTRACE_TPI_MESSAGE : break;
		case VKTRACE_TPI_MARKER_CHECKPOINT : break;
		case VKTRACE_TPI_MARKER_API_BOUNDARY : break;
		case VKTRACE_TPI_MARKER_API_GROUP_BEGIN : break;
		case VKTRACE_TPI_MARKER_API_GROUP_END : break;
		case VKTRACE_TPI_MARKER_TERMINATE_PROCESS : break;
		case VKTRACE_TPI_PORTABILITY_TABLE : break;
		case VKTRACE_TPI_VK_vkApiVersion : {
			packet_vkApiVersion* packet = BitCast<packet_vkApiVersion*>(header->pBody);
			packet->header = header;
			break;
		}
		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalImageFormatPropertiesNV : {
			packet_vkGetPhysicalDeviceExternalImageFormatPropertiesNV*  packet = BitCast<packet_vkGetPhysicalDeviceExternalImageFormatPropertiesNV*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalImageFormatProperties, header );
			Unpack_VkExternalImageFormatPropertiesNV( PtrCast<VkExternalImageFormatPropertiesNV>(packet->pExternalImageFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndirectCountAMD : {
			packet_vkCmdDrawIndirectCountAMD*  packet = BitCast<packet_vkCmdDrawIndirectCountAMD*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndexedIndirectCountAMD : {
			packet_vkCmdDrawIndexedIndirectCountAMD*  packet = BitCast<packet_vkCmdDrawIndexedIndirectCountAMD*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDebugReportCallbackEXT : {
			packet_vkCreateDebugReportCallbackEXT*  packet = BitCast<packet_vkCreateDebugReportCallbackEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pCallback, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDebugReportCallbackEXT : {
			packet_vkDestroyDebugReportCallbackEXT*  packet = BitCast<packet_vkDestroyDebugReportCallbackEXT*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkDebugReportMessageEXT : {
			packet_vkDebugReportMessageEXT*  packet = BitCast<packet_vkDebugReportMessageEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pLayerPrefix, header );
			UnpackPointer( INOUT packet->pMessage, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDebugMarkerSetObjectTagEXT : {
			packet_vkDebugMarkerSetObjectTagEXT*  packet = BitCast<packet_vkDebugMarkerSetObjectTagEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pTagInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pTagInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkDebugMarkerSetObjectNameEXT : {
			packet_vkDebugMarkerSetObjectNameEXT*  packet = BitCast<packet_vkDebugMarkerSetObjectNameEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pNameInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pNameInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDebugMarkerBeginEXT : {
			packet_vkCmdDebugMarkerBeginEXT*  packet = BitCast<packet_vkCmdDebugMarkerBeginEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMarkerInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMarkerInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDebugMarkerEndEXT : {
			packet_vkCmdDebugMarkerEndEXT*  packet = BitCast<packet_vkCmdDebugMarkerEndEXT*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDebugMarkerInsertEXT : {
			packet_vkCmdDebugMarkerInsertEXT*  packet = BitCast<packet_vkCmdDebugMarkerInsertEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMarkerInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMarkerInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateInstance : {
			packet_vkCreateInstance*  packet = BitCast<packet_vkCreateInstance*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pInstance, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyInstance : {
			packet_vkDestroyInstance*  packet = BitCast<packet_vkDestroyInstance*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkEnumeratePhysicalDevices : {
			packet_vkEnumeratePhysicalDevices*  packet = BitCast<packet_vkEnumeratePhysicalDevices*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPhysicalDeviceCount, header );
			UnpackPointer( INOUT packet->pPhysicalDevices, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFeatures : {
			packet_vkGetPhysicalDeviceFeatures*  packet = BitCast<packet_vkGetPhysicalDeviceFeatures*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFeatures, header );
			Unpack_VkPhysicalDeviceFeatures( PtrCast<VkPhysicalDeviceFeatures>(packet->pFeatures), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFormatProperties : {
			packet_vkGetPhysicalDeviceFormatProperties*  packet = BitCast<packet_vkGetPhysicalDeviceFormatProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatProperties, header );
			Unpack_VkFormatProperties( PtrCast<VkFormatProperties>(packet->pFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceImageFormatProperties : {
			packet_vkGetPhysicalDeviceImageFormatProperties*  packet = BitCast<packet_vkGetPhysicalDeviceImageFormatProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImageFormatProperties, header );
			Unpack_VkImageFormatProperties( PtrCast<VkImageFormatProperties>(packet->pImageFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceProperties : {
			packet_vkGetPhysicalDeviceProperties*  packet = BitCast<packet_vkGetPhysicalDeviceProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkPhysicalDeviceProperties( PtrCast<VkPhysicalDeviceProperties>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceQueueFamilyProperties : {
			packet_vkGetPhysicalDeviceQueueFamilyProperties*  packet = BitCast<packet_vkGetPhysicalDeviceQueueFamilyProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueueFamilyPropertyCount, header );
			UnpackPointer( INOUT packet->pQueueFamilyProperties, header );
			Unpack_VkQueueFamilyProperties( PtrCast<VkQueueFamilyProperties>(packet->pQueueFamilyProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceMemoryProperties : {
			packet_vkGetPhysicalDeviceMemoryProperties*  packet = BitCast<packet_vkGetPhysicalDeviceMemoryProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryProperties, header );
			Unpack_VkPhysicalDeviceMemoryProperties( PtrCast<VkPhysicalDeviceMemoryProperties>(packet->pMemoryProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetInstanceProcAddr : {
			packet_vkGetInstanceProcAddr*  packet = BitCast<packet_vkGetInstanceProcAddr*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pName, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceProcAddr : {
			packet_vkGetDeviceProcAddr*  packet = BitCast<packet_vkGetDeviceProcAddr*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pName, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDevice : {
			packet_vkCreateDevice*  packet = BitCast<packet_vkCreateDevice*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pDevice, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDevice : {
			packet_vkDestroyDevice*  packet = BitCast<packet_vkDestroyDevice*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateInstanceExtensionProperties : {
			packet_vkEnumerateInstanceExtensionProperties*  packet = BitCast<packet_vkEnumerateInstanceExtensionProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pLayerName, header );
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkExtensionProperties( PtrCast<VkExtensionProperties>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateDeviceExtensionProperties : {
			packet_vkEnumerateDeviceExtensionProperties*  packet = BitCast<packet_vkEnumerateDeviceExtensionProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pLayerName, header );
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkExtensionProperties( PtrCast<VkExtensionProperties>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateInstanceLayerProperties : {
			packet_vkEnumerateInstanceLayerProperties*  packet = BitCast<packet_vkEnumerateInstanceLayerProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkLayerProperties( PtrCast<VkLayerProperties>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateDeviceLayerProperties : {
			packet_vkEnumerateDeviceLayerProperties*  packet = BitCast<packet_vkEnumerateDeviceLayerProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkLayerProperties( PtrCast<VkLayerProperties>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceQueue : {
			packet_vkGetDeviceQueue*  packet = BitCast<packet_vkGetDeviceQueue*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueue, header );
			break;
		}

		case VKTRACE_TPI_VK_vkQueueSubmit : {
			packet_vkQueueSubmit*  packet = BitCast<packet_vkQueueSubmit*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSubmits, header );
			for (uint i = 0; (packet->pSubmits != null) and (i < packet->submitCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSubmits + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkQueueWaitIdle : {
			packet_vkQueueWaitIdle*  packet = BitCast<packet_vkQueueWaitIdle*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkDeviceWaitIdle : {
			packet_vkDeviceWaitIdle*  packet = BitCast<packet_vkDeviceWaitIdle*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkAllocateMemory : {
			packet_vkAllocateMemory*  packet = BitCast<packet_vkAllocateMemory*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAllocateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pAllocateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pMemory, header );
			break;
		}

		case VKTRACE_TPI_VK_vkFreeMemory : {
			packet_vkFreeMemory*  packet = BitCast<packet_vkFreeMemory*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkMapMemory : {
			packet_vkMapMemory*  packet = BitCast<packet_vkMapMemory*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->ppData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkUnmapMemory : {
			packet_vkUnmapMemory*  packet = BitCast<packet_vkUnmapMemory*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkFlushMappedMemoryRanges : {
			packet_vkFlushMappedMemoryRanges*  packet = BitCast<packet_vkFlushMappedMemoryRanges*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryRanges, header );
			UnpackPointer( INOUT packet->ppData, header );
			for (uint i = 0; (packet->ppData != null) and (i < packet->memoryRangeCount); ++i) {
				UnpackPointer( INOUT packet->ppData[i], header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkInvalidateMappedMemoryRanges : {
			packet_vkInvalidateMappedMemoryRanges*  packet = BitCast<packet_vkInvalidateMappedMemoryRanges*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryRanges, header );
			UnpackPointer( INOUT packet->ppData, header );
			for (uint i = 0; (packet->ppData != null) and (i < packet->memoryRangeCount); ++i) {
				UnpackPointer( INOUT packet->ppData[i], header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceMemoryCommitment : {
			packet_vkGetDeviceMemoryCommitment*  packet = BitCast<packet_vkGetDeviceMemoryCommitment*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCommittedMemoryInBytes, header );
			break;
		}

		case VKTRACE_TPI_VK_vkBindBufferMemory : {
			packet_vkBindBufferMemory*  packet = BitCast<packet_vkBindBufferMemory*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkBindImageMemory : {
			packet_vkBindImageMemory*  packet = BitCast<packet_vkBindImageMemory*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkGetBufferMemoryRequirements : {
			packet_vkGetBufferMemoryRequirements*  packet = BitCast<packet_vkGetBufferMemoryRequirements*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			Unpack_VkMemoryRequirements( PtrCast<VkMemoryRequirements>(packet->pMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageMemoryRequirements : {
			packet_vkGetImageMemoryRequirements*  packet = BitCast<packet_vkGetImageMemoryRequirements*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			Unpack_VkMemoryRequirements( PtrCast<VkMemoryRequirements>(packet->pMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageSparseMemoryRequirements : {
			packet_vkGetImageSparseMemoryRequirements*  packet = BitCast<packet_vkGetImageSparseMemoryRequirements*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSparseMemoryRequirementCount, header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirements, header );
			Unpack_VkSparseImageMemoryRequirements( PtrCast<VkSparseImageMemoryRequirements>(packet->pSparseMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSparseImageFormatProperties : {
			packet_vkGetPhysicalDeviceSparseImageFormatProperties*  packet = BitCast<packet_vkGetPhysicalDeviceSparseImageFormatProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkSparseImageFormatProperties( PtrCast<VkSparseImageFormatProperties>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkQueueBindSparse : {
			packet_vkQueueBindSparse*  packet = BitCast<packet_vkQueueBindSparse*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfo, header );
			for (uint i = 0; (packet->pBindInfo != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pBindInfo + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCreateFence : {
			packet_vkCreateFence*  packet = BitCast<packet_vkCreateFence*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pFence, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyFence : {
			packet_vkDestroyFence*  packet = BitCast<packet_vkDestroyFence*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkResetFences : {
			packet_vkResetFences*  packet = BitCast<packet_vkResetFences*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFences, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetFenceStatus : {
			packet_vkGetFenceStatus*  packet = BitCast<packet_vkGetFenceStatus*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkWaitForFences : {
			packet_vkWaitForFences*  packet = BitCast<packet_vkWaitForFences*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFences, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSemaphore : {
			packet_vkCreateSemaphore*  packet = BitCast<packet_vkCreateSemaphore*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSemaphore, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySemaphore : {
			packet_vkDestroySemaphore*  packet = BitCast<packet_vkDestroySemaphore*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateEvent : {
			packet_vkCreateEvent*  packet = BitCast<packet_vkCreateEvent*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pEvent, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyEvent : {
			packet_vkDestroyEvent*  packet = BitCast<packet_vkDestroyEvent*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetEventStatus : {
			packet_vkGetEventStatus*  packet = BitCast<packet_vkGetEventStatus*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkSetEvent : {
			packet_vkSetEvent*  packet = BitCast<packet_vkSetEvent*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkResetEvent : {
			packet_vkResetEvent*  packet = BitCast<packet_vkResetEvent*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateQueryPool : {
			packet_vkCreateQueryPool*  packet = BitCast<packet_vkCreateQueryPool*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pQueryPool, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyQueryPool : {
			packet_vkDestroyQueryPool*  packet = BitCast<packet_vkDestroyQueryPool*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetQueryPoolResults : {
			packet_vkGetQueryPoolResults*  packet = BitCast<packet_vkGetQueryPoolResults*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateBuffer : {
			packet_vkCreateBuffer*  packet = BitCast<packet_vkCreateBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pBuffer, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyBuffer : {
			packet_vkDestroyBuffer*  packet = BitCast<packet_vkDestroyBuffer*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateBufferView : {
			packet_vkCreateBufferView*  packet = BitCast<packet_vkCreateBufferView*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pView, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyBufferView : {
			packet_vkDestroyBufferView*  packet = BitCast<packet_vkDestroyBufferView*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateImage : {
			packet_vkCreateImage*  packet = BitCast<packet_vkCreateImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pImage, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyImage : {
			packet_vkDestroyImage*  packet = BitCast<packet_vkDestroyImage*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageSubresourceLayout : {
			packet_vkGetImageSubresourceLayout*  packet = BitCast<packet_vkGetImageSubresourceLayout*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSubresource, header );
			Unpack_VkImageSubresource( PtrCast<VkImageSubresource>(packet->pSubresource), header );
			UnpackPointer( INOUT packet->pLayout, header );
			Unpack_VkSubresourceLayout( PtrCast<VkSubresourceLayout>(packet->pLayout), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateImageView : {
			packet_vkCreateImageView*  packet = BitCast<packet_vkCreateImageView*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pView, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyImageView : {
			packet_vkDestroyImageView*  packet = BitCast<packet_vkDestroyImageView*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateShaderModule : {
			packet_vkCreateShaderModule*  packet = BitCast<packet_vkCreateShaderModule*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pShaderModule, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyShaderModule : {
			packet_vkDestroyShaderModule*  packet = BitCast<packet_vkDestroyShaderModule*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreatePipelineCache : {
			packet_vkCreatePipelineCache*  packet = BitCast<packet_vkCreatePipelineCache*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pPipelineCache, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyPipelineCache : {
			packet_vkDestroyPipelineCache*  packet = BitCast<packet_vkDestroyPipelineCache*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPipelineCacheData : {
			packet_vkGetPipelineCacheData*  packet = BitCast<packet_vkGetPipelineCacheData*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDataSize, header );
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkMergePipelineCaches : {
			packet_vkMergePipelineCaches*  packet = BitCast<packet_vkMergePipelineCaches*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSrcCaches, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateGraphicsPipelines : {
			packet_vkCreateGraphicsPipelines*  packet = BitCast<packet_vkCreateGraphicsPipelines*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfos, header );
			for (uint i = 0; (packet->pCreateInfos != null) and (i < packet->createInfoCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfos + i), header );
			}
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pPipelines, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateComputePipelines : {
			packet_vkCreateComputePipelines*  packet = BitCast<packet_vkCreateComputePipelines*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfos, header );
			for (uint i = 0; (packet->pCreateInfos != null) and (i < packet->createInfoCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfos + i), header );
			}
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pPipelines, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyPipeline : {
			packet_vkDestroyPipeline*  packet = BitCast<packet_vkDestroyPipeline*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreatePipelineLayout : {
			packet_vkCreatePipelineLayout*  packet = BitCast<packet_vkCreatePipelineLayout*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pPipelineLayout, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyPipelineLayout : {
			packet_vkDestroyPipelineLayout*  packet = BitCast<packet_vkDestroyPipelineLayout*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSampler : {
			packet_vkCreateSampler*  packet = BitCast<packet_vkCreateSampler*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSampler, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySampler : {
			packet_vkDestroySampler*  packet = BitCast<packet_vkDestroySampler*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDescriptorSetLayout : {
			packet_vkCreateDescriptorSetLayout*  packet = BitCast<packet_vkCreateDescriptorSetLayout*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSetLayout, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDescriptorSetLayout : {
			packet_vkDestroyDescriptorSetLayout*  packet = BitCast<packet_vkDestroyDescriptorSetLayout*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDescriptorPool : {
			packet_vkCreateDescriptorPool*  packet = BitCast<packet_vkCreateDescriptorPool*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pDescriptorPool, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDescriptorPool : {
			packet_vkDestroyDescriptorPool*  packet = BitCast<packet_vkDestroyDescriptorPool*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkResetDescriptorPool : {
			packet_vkResetDescriptorPool*  packet = BitCast<packet_vkResetDescriptorPool*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkAllocateDescriptorSets : {
			packet_vkAllocateDescriptorSets*  packet = BitCast<packet_vkAllocateDescriptorSets*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAllocateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pAllocateInfo), header );
			UnpackPointer( INOUT packet->pDescriptorSets, header );
			break;
		}

		case VKTRACE_TPI_VK_vkFreeDescriptorSets : {
			packet_vkFreeDescriptorSets*  packet = BitCast<packet_vkFreeDescriptorSets*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDescriptorSets, header );
			break;
		}

		case VKTRACE_TPI_VK_vkUpdateDescriptorSets : {
			packet_vkUpdateDescriptorSets*  packet = BitCast<packet_vkUpdateDescriptorSets*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDescriptorWrites, header );
			for (uint i = 0; (packet->pDescriptorWrites != null) and (i < packet->descriptorWriteCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pDescriptorWrites + i), header );
			}
			UnpackPointer( INOUT packet->pDescriptorCopies, header );
			for (uint i = 0; (packet->pDescriptorCopies != null) and (i < packet->descriptorCopyCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pDescriptorCopies + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCreateFramebuffer : {
			packet_vkCreateFramebuffer*  packet = BitCast<packet_vkCreateFramebuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pFramebuffer, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyFramebuffer : {
			packet_vkDestroyFramebuffer*  packet = BitCast<packet_vkDestroyFramebuffer*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateRenderPass : {
			packet_vkCreateRenderPass*  packet = BitCast<packet_vkCreateRenderPass*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pRenderPass, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyRenderPass : {
			packet_vkDestroyRenderPass*  packet = BitCast<packet_vkDestroyRenderPass*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetRenderAreaGranularity : {
			packet_vkGetRenderAreaGranularity*  packet = BitCast<packet_vkGetRenderAreaGranularity*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGranularity, header );
			Unpack_VkExtent2D( PtrCast<VkExtent2D>(packet->pGranularity), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateCommandPool : {
			packet_vkCreateCommandPool*  packet = BitCast<packet_vkCreateCommandPool*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pCommandPool, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyCommandPool : {
			packet_vkDestroyCommandPool*  packet = BitCast<packet_vkDestroyCommandPool*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkResetCommandPool : {
			packet_vkResetCommandPool*  packet = BitCast<packet_vkResetCommandPool*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkAllocateCommandBuffers : {
			packet_vkAllocateCommandBuffers*  packet = BitCast<packet_vkAllocateCommandBuffers*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAllocateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pAllocateInfo), header );
			UnpackPointer( INOUT packet->pCommandBuffers, header );
			break;
		}

		case VKTRACE_TPI_VK_vkFreeCommandBuffers : {
			packet_vkFreeCommandBuffers*  packet = BitCast<packet_vkFreeCommandBuffers*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCommandBuffers, header );
			break;
		}

		case VKTRACE_TPI_VK_vkBeginCommandBuffer : {
			packet_vkBeginCommandBuffer*  packet = BitCast<packet_vkBeginCommandBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBeginInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pBeginInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkEndCommandBuffer : {
			packet_vkEndCommandBuffer*  packet = BitCast<packet_vkEndCommandBuffer*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkResetCommandBuffer : {
			packet_vkResetCommandBuffer*  packet = BitCast<packet_vkResetCommandBuffer*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBindPipeline : {
			packet_vkCmdBindPipeline*  packet = BitCast<packet_vkCmdBindPipeline*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetViewport : {
			packet_vkCmdSetViewport*  packet = BitCast<packet_vkCmdSetViewport*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pViewports, header );
			for (uint i = 0; (packet->pViewports != null) and (i < packet->viewportCount); ++i) {
				Unpack_VkViewport( PtrCast<VkViewport>(packet->pViewports + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetScissor : {
			packet_vkCmdSetScissor*  packet = BitCast<packet_vkCmdSetScissor*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pScissors, header );
			for (uint i = 0; (packet->pScissors != null) and (i < packet->scissorCount); ++i) {
				Unpack_VkRect2D( PtrCast<VkRect2D>(packet->pScissors + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetLineWidth : {
			packet_vkCmdSetLineWidth*  packet = BitCast<packet_vkCmdSetLineWidth*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDepthBias : {
			packet_vkCmdSetDepthBias*  packet = BitCast<packet_vkCmdSetDepthBias*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetBlendConstants : {
			packet_vkCmdSetBlendConstants*  packet = BitCast<packet_vkCmdSetBlendConstants*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDepthBounds : {
			packet_vkCmdSetDepthBounds*  packet = BitCast<packet_vkCmdSetDepthBounds*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetStencilCompareMask : {
			packet_vkCmdSetStencilCompareMask*  packet = BitCast<packet_vkCmdSetStencilCompareMask*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetStencilWriteMask : {
			packet_vkCmdSetStencilWriteMask*  packet = BitCast<packet_vkCmdSetStencilWriteMask*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetStencilReference : {
			packet_vkCmdSetStencilReference*  packet = BitCast<packet_vkCmdSetStencilReference*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBindDescriptorSets : {
			packet_vkCmdBindDescriptorSets*  packet = BitCast<packet_vkCmdBindDescriptorSets*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDescriptorSets, header );
			UnpackPointer( INOUT packet->pDynamicOffsets, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBindIndexBuffer : {
			packet_vkCmdBindIndexBuffer*  packet = BitCast<packet_vkCmdBindIndexBuffer*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBindVertexBuffers : {
			packet_vkCmdBindVertexBuffers*  packet = BitCast<packet_vkCmdBindVertexBuffers*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBuffers, header );
			UnpackPointer( INOUT packet->pOffsets, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDraw : {
			packet_vkCmdDraw*  packet = BitCast<packet_vkCmdDraw*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndexed : {
			packet_vkCmdDrawIndexed*  packet = BitCast<packet_vkCmdDrawIndexed*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndirect : {
			packet_vkCmdDrawIndirect*  packet = BitCast<packet_vkCmdDrawIndirect*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndexedIndirect : {
			packet_vkCmdDrawIndexedIndirect*  packet = BitCast<packet_vkCmdDrawIndexedIndirect*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDispatch : {
			packet_vkCmdDispatch*  packet = BitCast<packet_vkCmdDispatch*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDispatchIndirect : {
			packet_vkCmdDispatchIndirect*  packet = BitCast<packet_vkCmdDispatchIndirect*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyBuffer : {
			packet_vkCmdCopyBuffer*  packet = BitCast<packet_vkCmdCopyBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkBufferCopy( PtrCast<VkBufferCopy>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyImage : {
			packet_vkCmdCopyImage*  packet = BitCast<packet_vkCmdCopyImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkImageCopy( PtrCast<VkImageCopy>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBlitImage : {
			packet_vkCmdBlitImage*  packet = BitCast<packet_vkCmdBlitImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkImageBlit( PtrCast<VkImageBlit>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyBufferToImage : {
			packet_vkCmdCopyBufferToImage*  packet = BitCast<packet_vkCmdCopyBufferToImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkBufferImageCopy( PtrCast<VkBufferImageCopy>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyImageToBuffer : {
			packet_vkCmdCopyImageToBuffer*  packet = BitCast<packet_vkCmdCopyImageToBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkBufferImageCopy( PtrCast<VkBufferImageCopy>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdUpdateBuffer : {
			packet_vkCmdUpdateBuffer*  packet = BitCast<packet_vkCmdUpdateBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdFillBuffer : {
			packet_vkCmdFillBuffer*  packet = BitCast<packet_vkCmdFillBuffer*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdClearColorImage : {
			packet_vkCmdClearColorImage*  packet = BitCast<packet_vkCmdClearColorImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pColor, header );
			Unpack_VkClearColorValue( PtrCast<VkClearColorValue>(packet->pColor), header );
			UnpackPointer( INOUT packet->pRanges, header );
			for (uint i = 0; (packet->pRanges != null) and (i < packet->rangeCount); ++i) {
				Unpack_VkImageSubresourceRange( PtrCast<VkImageSubresourceRange>(packet->pRanges + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdClearDepthStencilImage : {
			packet_vkCmdClearDepthStencilImage*  packet = BitCast<packet_vkCmdClearDepthStencilImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDepthStencil, header );
			Unpack_VkClearDepthStencilValue( PtrCast<VkClearDepthStencilValue>(packet->pDepthStencil), header );
			UnpackPointer( INOUT packet->pRanges, header );
			for (uint i = 0; (packet->pRanges != null) and (i < packet->rangeCount); ++i) {
				Unpack_VkImageSubresourceRange( PtrCast<VkImageSubresourceRange>(packet->pRanges + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdClearAttachments : {
			packet_vkCmdClearAttachments*  packet = BitCast<packet_vkCmdClearAttachments*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAttachments, header );
			for (uint i = 0; (packet->pAttachments != null) and (i < packet->attachmentCount); ++i) {
				Unpack_VkClearAttachment( PtrCast<VkClearAttachment>(packet->pAttachments + i), header );
			}
			UnpackPointer( INOUT packet->pRects, header );
			for (uint i = 0; (packet->pRects != null) and (i < packet->rectCount); ++i) {
				Unpack_VkClearRect( PtrCast<VkClearRect>(packet->pRects + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdResolveImage : {
			packet_vkCmdResolveImage*  packet = BitCast<packet_vkCmdResolveImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkImageResolve( PtrCast<VkImageResolve>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetEvent : {
			packet_vkCmdSetEvent*  packet = BitCast<packet_vkCmdSetEvent*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdResetEvent : {
			packet_vkCmdResetEvent*  packet = BitCast<packet_vkCmdResetEvent*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdWaitEvents : {
			packet_vkCmdWaitEvents*  packet = BitCast<packet_vkCmdWaitEvents*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pEvents, header );
			UnpackPointer( INOUT packet->pMemoryBarriers, header );
			for (uint i = 0; (packet->pMemoryBarriers != null) and (i < packet->memoryBarrierCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryBarriers + i), header );
			}
			UnpackPointer( INOUT packet->pBufferMemoryBarriers, header );
			for (uint i = 0; (packet->pBufferMemoryBarriers != null) and (i < packet->bufferMemoryBarrierCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pBufferMemoryBarriers + i), header );
			}
			UnpackPointer( INOUT packet->pImageMemoryBarriers, header );
			for (uint i = 0; (packet->pImageMemoryBarriers != null) and (i < packet->imageMemoryBarrierCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImageMemoryBarriers + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdPipelineBarrier : {
			packet_vkCmdPipelineBarrier*  packet = BitCast<packet_vkCmdPipelineBarrier*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryBarriers, header );
			for (uint i = 0; (packet->pMemoryBarriers != null) and (i < packet->memoryBarrierCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryBarriers + i), header );
			}
			UnpackPointer( INOUT packet->pBufferMemoryBarriers, header );
			for (uint i = 0; (packet->pBufferMemoryBarriers != null) and (i < packet->bufferMemoryBarrierCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pBufferMemoryBarriers + i), header );
			}
			UnpackPointer( INOUT packet->pImageMemoryBarriers, header );
			for (uint i = 0; (packet->pImageMemoryBarriers != null) and (i < packet->imageMemoryBarrierCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImageMemoryBarriers + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBeginQuery : {
			packet_vkCmdBeginQuery*  packet = BitCast<packet_vkCmdBeginQuery*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdEndQuery : {
			packet_vkCmdEndQuery*  packet = BitCast<packet_vkCmdEndQuery*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdResetQueryPool : {
			packet_vkCmdResetQueryPool*  packet = BitCast<packet_vkCmdResetQueryPool*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdWriteTimestamp : {
			packet_vkCmdWriteTimestamp*  packet = BitCast<packet_vkCmdWriteTimestamp*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyQueryPoolResults : {
			packet_vkCmdCopyQueryPoolResults*  packet = BitCast<packet_vkCmdCopyQueryPoolResults*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdPushConstants : {
			packet_vkCmdPushConstants*  packet = BitCast<packet_vkCmdPushConstants*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pValues, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBeginRenderPass : {
			packet_vkCmdBeginRenderPass*  packet = BitCast<packet_vkCmdBeginRenderPass*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRenderPassBegin, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pRenderPassBegin), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdNextSubpass : {
			packet_vkCmdNextSubpass*  packet = BitCast<packet_vkCmdNextSubpass*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdEndRenderPass : {
			packet_vkCmdEndRenderPass*  packet = BitCast<packet_vkCmdEndRenderPass*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdExecuteCommands : {
			packet_vkCmdExecuteCommands*  packet = BitCast<packet_vkCmdExecuteCommands*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCommandBuffers, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySurfaceKHR : {
			packet_vkDestroySurfaceKHR*  packet = BitCast<packet_vkDestroySurfaceKHR*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceSupportKHR : {
			packet_vkGetPhysicalDeviceSurfaceSupportKHR*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceSupportKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSupported, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceCapabilitiesKHR : {
			packet_vkGetPhysicalDeviceSurfaceCapabilitiesKHR*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceCapabilitiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceCapabilities, header );
			Unpack_VkSurfaceCapabilitiesKHR( PtrCast<VkSurfaceCapabilitiesKHR>(packet->pSurfaceCapabilities), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceFormatsKHR : {
			packet_vkGetPhysicalDeviceSurfaceFormatsKHR*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceFormatsKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceFormatCount, header );
			UnpackPointer( INOUT packet->pSurfaceFormats, header );
			Unpack_VkSurfaceFormatKHR( PtrCast<VkSurfaceFormatKHR>(packet->pSurfaceFormats), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfacePresentModesKHR : {
			packet_vkGetPhysicalDeviceSurfacePresentModesKHR*  packet = BitCast<packet_vkGetPhysicalDeviceSurfacePresentModesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPresentModeCount, header );
			UnpackPointer( INOUT packet->pPresentModes, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSwapchainKHR : {
			packet_vkCreateSwapchainKHR*  packet = BitCast<packet_vkCreateSwapchainKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSwapchain, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySwapchainKHR : {
			packet_vkDestroySwapchainKHR*  packet = BitCast<packet_vkDestroySwapchainKHR*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetSwapchainImagesKHR : {
			packet_vkGetSwapchainImagesKHR*  packet = BitCast<packet_vkGetSwapchainImagesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSwapchainImageCount, header );
			UnpackPointer( INOUT packet->pSwapchainImages, header );
			break;
		}

		case VKTRACE_TPI_VK_vkAcquireNextImageKHR : {
			packet_vkAcquireNextImageKHR*  packet = BitCast<packet_vkAcquireNextImageKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImageIndex, header );
			break;
		}

		case VKTRACE_TPI_VK_vkQueuePresentKHR : {
			packet_vkQueuePresentKHR*  packet = BitCast<packet_vkQueuePresentKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPresentInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pPresentInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSharedSwapchainsKHR : {
			packet_vkCreateSharedSwapchainsKHR*  packet = BitCast<packet_vkCreateSharedSwapchainsKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfos, header );
			for (uint i = 0; (packet->pCreateInfos != null) and (i < packet->swapchainCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfos + i), header );
			}
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSwapchains, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateWin32SurfaceKHR : {
			packet_vkCreateWin32SurfaceKHR*  packet = BitCast<packet_vkCreateWin32SurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceWin32PresentationSupportKHR : {
			packet_vkGetPhysicalDeviceWin32PresentationSupportKHR*  packet = BitCast<packet_vkGetPhysicalDeviceWin32PresentationSupportKHR*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateXlibSurfaceKHR : {
			packet_vkCreateXlibSurfaceKHR*  packet = BitCast<packet_vkCreateXlibSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceXlibPresentationSupportKHR : {
			packet_vkGetPhysicalDeviceXlibPresentationSupportKHR*  packet = BitCast<packet_vkGetPhysicalDeviceXlibPresentationSupportKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->dpy, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateXcbSurfaceKHR : {
			packet_vkCreateXcbSurfaceKHR*  packet = BitCast<packet_vkCreateXcbSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceXcbPresentationSupportKHR : {
			packet_vkGetPhysicalDeviceXcbPresentationSupportKHR*  packet = BitCast<packet_vkGetPhysicalDeviceXcbPresentationSupportKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->connection, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateAndroidSurfaceKHR : {
			packet_vkCreateAndroidSurfaceKHR*  packet = BitCast<packet_vkCreateAndroidSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryWin32HandleNV : {
			packet_vkGetMemoryWin32HandleNV*  packet = BitCast<packet_vkGetMemoryWin32HandleNV*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pHandle, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDescriptorUpdateTemplateKHR : {
			packet_vkCreateDescriptorUpdateTemplateKHR*  packet = BitCast<packet_vkCreateDescriptorUpdateTemplateKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pDescriptorUpdateTemplate, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDescriptorUpdateTemplateKHR : {
			packet_vkDestroyDescriptorUpdateTemplateKHR*  packet = BitCast<packet_vkDestroyDescriptorUpdateTemplateKHR*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkUpdateDescriptorSetWithTemplateKHR : {
			packet_vkUpdateDescriptorSetWithTemplateKHR*  packet = BitCast<packet_vkUpdateDescriptorSetWithTemplateKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdPushDescriptorSetWithTemplateKHR : {
			packet_vkCmdPushDescriptorSetWithTemplateKHR*  packet = BitCast<packet_vkCmdPushDescriptorSetWithTemplateKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateWaylandSurfaceKHR : {
			packet_vkCreateWaylandSurfaceKHR*  packet = BitCast<packet_vkCreateWaylandSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceWaylandPresentationSupportKHR : {
			packet_vkGetPhysicalDeviceWaylandPresentationSupportKHR*  packet = BitCast<packet_vkGetPhysicalDeviceWaylandPresentationSupportKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->display, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFeatures2KHR : {
			packet_vkGetPhysicalDeviceFeatures2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceFeatures2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFeatures, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pFeatures), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceProperties2KHR : {
			packet_vkGetPhysicalDeviceProperties2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFormatProperties2KHR : {
			packet_vkGetPhysicalDeviceFormatProperties2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceFormatProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceImageFormatProperties2KHR : {
			packet_vkGetPhysicalDeviceImageFormatProperties2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceImageFormatProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImageFormatInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImageFormatInfo), header );
			UnpackPointer( INOUT packet->pImageFormatProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImageFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceQueueFamilyProperties2KHR : {
			packet_vkGetPhysicalDeviceQueueFamilyProperties2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceQueueFamilyProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueueFamilyPropertyCount, header );
			UnpackPointer( INOUT packet->pQueueFamilyProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pQueueFamilyProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceMemoryProperties2KHR : {
			packet_vkGetPhysicalDeviceMemoryProperties2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceMemoryProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSparseImageFormatProperties2KHR : {
			packet_vkGetPhysicalDeviceSparseImageFormatProperties2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceSparseImageFormatProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pFormatInfo), header );
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageMemoryRequirements2KHR : {
			packet_vkGetImageMemoryRequirements2KHR*  packet = BitCast<packet_vkGetImageMemoryRequirements2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pInfo), header );
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetBufferMemoryRequirements2KHR : {
			packet_vkGetBufferMemoryRequirements2KHR*  packet = BitCast<packet_vkGetBufferMemoryRequirements2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pInfo), header );
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageSparseMemoryRequirements2KHR : {
			packet_vkGetImageSparseMemoryRequirements2KHR*  packet = BitCast<packet_vkGetImageSparseMemoryRequirements2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pInfo), header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirementCount, header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirements, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSparseMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceCapabilities2KHR : {
			packet_vkGetPhysicalDeviceSurfaceCapabilities2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceCapabilities2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSurfaceInfo), header );
			UnpackPointer( INOUT packet->pSurfaceCapabilities, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSurfaceCapabilities), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceFormats2KHR : {
			packet_vkGetPhysicalDeviceSurfaceFormats2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceFormats2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSurfaceInfo), header );
			UnpackPointer( INOUT packet->pSurfaceFormatCount, header );
			UnpackPointer( INOUT packet->pSurfaceFormats, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSurfaceFormats), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceDisplayPropertiesKHR : {
			packet_vkGetPhysicalDeviceDisplayPropertiesKHR*  packet = BitCast<packet_vkGetPhysicalDeviceDisplayPropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkDisplayPropertiesKHR( PtrCast<VkDisplayPropertiesKHR>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceDisplayPlanePropertiesKHR : {
			packet_vkGetPhysicalDeviceDisplayPlanePropertiesKHR*  packet = BitCast<packet_vkGetPhysicalDeviceDisplayPlanePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkDisplayPlanePropertiesKHR( PtrCast<VkDisplayPlanePropertiesKHR>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayModePropertiesKHR : {
			packet_vkGetDisplayModePropertiesKHR*  packet = BitCast<packet_vkGetDisplayModePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkDisplayModePropertiesKHR( PtrCast<VkDisplayModePropertiesKHR>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDisplayModeKHR : {
			packet_vkCreateDisplayModeKHR*  packet = BitCast<packet_vkCreateDisplayModeKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pMode, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayPlaneCapabilitiesKHR : {
			packet_vkGetDisplayPlaneCapabilitiesKHR*  packet = BitCast<packet_vkGetDisplayPlaneCapabilitiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCapabilities, header );
			Unpack_VkDisplayPlaneCapabilitiesKHR( PtrCast<VkDisplayPlaneCapabilitiesKHR>(packet->pCapabilities), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDisplayPlaneSurfaceKHR : {
			packet_vkCreateDisplayPlaneSurfaceKHR*  packet = BitCast<packet_vkCreateDisplayPlaneSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkTrimCommandPoolKHR : {
			packet_vkTrimCommandPoolKHR*  packet = BitCast<packet_vkTrimCommandPoolKHR*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalBufferPropertiesKHR : {
			packet_vkGetPhysicalDeviceExternalBufferPropertiesKHR*  packet = BitCast<packet_vkGetPhysicalDeviceExternalBufferPropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalBufferInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalBufferInfo), header );
			UnpackPointer( INOUT packet->pExternalBufferProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalBufferProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryFdKHR : {
			packet_vkGetMemoryFdKHR*  packet = BitCast<packet_vkGetMemoryFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetFdInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pGetFdInfo), header );
			UnpackPointer( INOUT packet->pFd, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryFdPropertiesKHR : {
			packet_vkGetMemoryFdPropertiesKHR*  packet = BitCast<packet_vkGetMemoryFdPropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryFdProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryFdProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR : {
			packet_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR*  packet = BitCast<packet_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalSemaphoreInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalSemaphoreInfo), header );
			UnpackPointer( INOUT packet->pExternalSemaphoreProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalSemaphoreProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkImportSemaphoreFdKHR : {
			packet_vkImportSemaphoreFdKHR*  packet = BitCast<packet_vkImportSemaphoreFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImportSemaphoreFdInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImportSemaphoreFdInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetSemaphoreFdKHR : {
			packet_vkGetSemaphoreFdKHR*  packet = BitCast<packet_vkGetSemaphoreFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetFdInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pGetFdInfo), header );
			UnpackPointer( INOUT packet->pFd, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdPushDescriptorSetKHR : {
			packet_vkCmdPushDescriptorSetKHR*  packet = BitCast<packet_vkCmdPushDescriptorSetKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDescriptorWrites, header );
			for (uint i = 0; (packet->pDescriptorWrites != null) and (i < packet->descriptorWriteCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pDescriptorWrites + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkGetSwapchainStatusKHR : {
			packet_vkGetSwapchainStatusKHR*  packet = BitCast<packet_vkGetSwapchainStatusKHR*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalFencePropertiesKHR : {
			packet_vkGetPhysicalDeviceExternalFencePropertiesKHR*  packet = BitCast<packet_vkGetPhysicalDeviceExternalFencePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalFenceInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalFenceInfo), header );
			UnpackPointer( INOUT packet->pExternalFenceProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalFenceProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceGroupPeerMemoryFeaturesKHX : break;
		case VKTRACE_TPI_VK_vkBindBufferMemory2KHR : {
			packet_vkBindBufferMemory2KHR*  packet = BitCast<packet_vkBindBufferMemory2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfos, header );
			for (uint i = 0; (packet->pBindInfos != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pBindInfos + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkBindImageMemory2KHR : {
			packet_vkBindImageMemory2KHR*  packet = BitCast<packet_vkBindImageMemory2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfos, header );
			for (uint i = 0; (packet->pBindInfos != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pBindInfos + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDeviceMaskKHX : break;
		case VKTRACE_TPI_VK_vkGetDeviceGroupPresentCapabilitiesKHX : break;
		case VKTRACE_TPI_VK_vkGetDeviceGroupSurfacePresentModesKHX : break;
		case VKTRACE_TPI_VK_vkAcquireNextImage2KHX : break;
		case VKTRACE_TPI_VK_vkCmdDispatchBaseKHX : break;
		case VKTRACE_TPI_VK_vkGetPhysicalDevicePresentRectanglesKHX : break;
		case VKTRACE_TPI_VK_vkEnumeratePhysicalDeviceGroupsKHX : break;
		case VKTRACE_TPI_VK_vkCmdProcessCommandsNVX : {
			packet_vkCmdProcessCommandsNVX*  packet = BitCast<packet_vkCmdProcessCommandsNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pProcessCommandsInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pProcessCommandsInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdReserveSpaceForCommandsNVX : {
			packet_vkCmdReserveSpaceForCommandsNVX*  packet = BitCast<packet_vkCmdReserveSpaceForCommandsNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pReserveSpaceInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pReserveSpaceInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateIndirectCommandsLayoutNVX : {
			packet_vkCreateIndirectCommandsLayoutNVX*  packet = BitCast<packet_vkCreateIndirectCommandsLayoutNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pIndirectCommandsLayout, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyIndirectCommandsLayoutNVX : {
			packet_vkDestroyIndirectCommandsLayoutNVX*  packet = BitCast<packet_vkDestroyIndirectCommandsLayoutNVX*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateObjectTableNVX : {
			packet_vkCreateObjectTableNVX*  packet = BitCast<packet_vkCreateObjectTableNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pObjectTable, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyObjectTableNVX : {
			packet_vkDestroyObjectTableNVX*  packet = BitCast<packet_vkDestroyObjectTableNVX*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkRegisterObjectsNVX : {
			packet_vkRegisterObjectsNVX*  packet = BitCast<packet_vkRegisterObjectsNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->ppObjectTableEntries, header );
			for (uint i = 0; (packet->ppObjectTableEntries != null) and (i < packet->objectCount); ++i) {
				Unpack_VkObjectTableEntryNVX( PtrCast<VkObjectTableEntryNVX>(packet->ppObjectTableEntries + i), header );
			}
			for (uint i = 0; (packet->ppObjectTableEntries != null) and (i < packet->objectCount); ++i) {
				UnpackPointer( INOUT packet->ppObjectTableEntries[i], header );
			}
			UnpackPointer( INOUT packet->pObjectIndices, header );
			break;
		}

		case VKTRACE_TPI_VK_vkUnregisterObjectsNVX : {
			packet_vkUnregisterObjectsNVX*  packet = BitCast<packet_vkUnregisterObjectsNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pObjectEntryTypes, header );
			UnpackPointer( INOUT packet->pObjectIndices, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX : {
			packet_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX*  packet = BitCast<packet_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFeatures, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pFeatures), header );
			UnpackPointer( INOUT packet->pLimits, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pLimits), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetViewportWScalingNV : {
			packet_vkCmdSetViewportWScalingNV*  packet = BitCast<packet_vkCmdSetViewportWScalingNV*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pViewportWScalings, header );
			for (uint i = 0; (packet->pViewportWScalings != null) and (i < packet->viewportCount); ++i) {
				Unpack_VkViewportWScalingNV( PtrCast<VkViewportWScalingNV>(packet->pViewportWScalings + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkReleaseDisplayEXT : {
			packet_vkReleaseDisplayEXT*  packet = BitCast<packet_vkReleaseDisplayEXT*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceCapabilities2EXT : {
			packet_vkGetPhysicalDeviceSurfaceCapabilities2EXT*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceCapabilities2EXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceCapabilities, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSurfaceCapabilities), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetRefreshCycleDurationGOOGLE : {
			packet_vkGetRefreshCycleDurationGOOGLE*  packet = BitCast<packet_vkGetRefreshCycleDurationGOOGLE*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayTimingProperties, header );
			Unpack_VkRefreshCycleDurationGOOGLE( PtrCast<VkRefreshCycleDurationGOOGLE>(packet->pDisplayTimingProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPastPresentationTimingGOOGLE : {
			packet_vkGetPastPresentationTimingGOOGLE*  packet = BitCast<packet_vkGetPastPresentationTimingGOOGLE*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPresentationTimingCount, header );
			UnpackPointer( INOUT packet->pPresentationTimings, header );
			Unpack_VkPastPresentationTimingGOOGLE( PtrCast<VkPastPresentationTimingGOOGLE>(packet->pPresentationTimings), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDiscardRectangleEXT : {
			packet_vkCmdSetDiscardRectangleEXT*  packet = BitCast<packet_vkCmdSetDiscardRectangleEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDiscardRectangles, header );
			for (uint i = 0; (packet->pDiscardRectangles != null) and (i < packet->discardRectangleCount); ++i) {
				Unpack_VkRect2D( PtrCast<VkRect2D>(packet->pDiscardRectangles + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkSetHdrMetadataEXT : {
			packet_vkSetHdrMetadataEXT*  packet = BitCast<packet_vkSetHdrMetadataEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSwapchains, header );
			UnpackPointer( INOUT packet->pMetadata, header );
			for (uint i = 0; (packet->pMetadata != null) and (i < packet->swapchainCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMetadata + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkAcquireXlibDisplayEXT : {
			packet_vkAcquireXlibDisplayEXT*  packet = BitCast<packet_vkAcquireXlibDisplayEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->dpy, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetRandROutputDisplayEXT : {
			packet_vkGetRandROutputDisplayEXT*  packet = BitCast<packet_vkGetRandROutputDisplayEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->dpy, header );
			UnpackPointer( INOUT packet->pDisplay, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDisplayPowerControlEXT : {
			packet_vkDisplayPowerControlEXT*  packet = BitCast<packet_vkDisplayPowerControlEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayPowerInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pDisplayPowerInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkRegisterDeviceEventEXT : {
			packet_vkRegisterDeviceEventEXT*  packet = BitCast<packet_vkRegisterDeviceEventEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDeviceEventInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pDeviceEventInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pFence, header );
			break;
		}

		case VKTRACE_TPI_VK_vkRegisterDisplayEventEXT : {
			packet_vkRegisterDisplayEventEXT*  packet = BitCast<packet_vkRegisterDisplayEventEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayEventInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pDisplayEventInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pFence, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetSwapchainCounterEXT : {
			packet_vkGetSwapchainCounterEXT*  packet = BitCast<packet_vkGetSwapchainCounterEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCounterValue, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetSampleLocationsEXT : {
			packet_vkCmdSetSampleLocationsEXT*  packet = BitCast<packet_vkCmdSetSampleLocationsEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSampleLocationsInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSampleLocationsInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceMultisamplePropertiesEXT : {
			packet_vkGetPhysicalDeviceMultisamplePropertiesEXT*  packet = BitCast<packet_vkGetPhysicalDeviceMultisamplePropertiesEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMultisampleProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMultisampleProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSamplerYcbcrConversionKHR : {
			packet_vkCreateSamplerYcbcrConversionKHR*  packet = BitCast<packet_vkCreateSamplerYcbcrConversionKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pYcbcrConversion, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySamplerYcbcrConversionKHR : {
			packet_vkDestroySamplerYcbcrConversionKHR*  packet = BitCast<packet_vkDestroySamplerYcbcrConversionKHR*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayPlaneSupportedDisplaysKHR : {
			packet_vkGetDisplayPlaneSupportedDisplaysKHR*  packet = BitCast<packet_vkGetDisplayPlaneSupportedDisplaysKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayCount, header );
			UnpackPointer( INOUT packet->pDisplays, header );
			break;
		}

		case VKTRACE_TPI_VK_vkImportFenceFdKHR : {
			packet_vkImportFenceFdKHR*  packet = BitCast<packet_vkImportFenceFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImportFenceFdInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImportFenceFdInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetFenceFdKHR : {
			packet_vkGetFenceFdKHR*  packet = BitCast<packet_vkGetFenceFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetFdInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pGetFdInfo), header );
			UnpackPointer( INOUT packet->pFd, header );
			break;
		}

		case VKTRACE_TPI_VK_vkImportFenceWin32HandleKHR : {
			packet_vkImportFenceWin32HandleKHR*  packet = BitCast<packet_vkImportFenceWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImportFenceWin32HandleInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImportFenceWin32HandleInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetFenceWin32HandleKHR : {
			packet_vkGetFenceWin32HandleKHR*  packet = BitCast<packet_vkGetFenceWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetWin32HandleInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pGetWin32HandleInfo), header );
			UnpackPointer( INOUT packet->pHandle, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryWin32HandleKHR : {
			packet_vkGetMemoryWin32HandleKHR*  packet = BitCast<packet_vkGetMemoryWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetWin32HandleInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pGetWin32HandleInfo), header );
			UnpackPointer( INOUT packet->pHandle, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryWin32HandlePropertiesKHR : {
			packet_vkGetMemoryWin32HandlePropertiesKHR*  packet = BitCast<packet_vkGetMemoryWin32HandlePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryWin32HandleProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryWin32HandleProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkImportSemaphoreWin32HandleKHR : {
			packet_vkImportSemaphoreWin32HandleKHR*  packet = BitCast<packet_vkImportSemaphoreWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImportSemaphoreWin32HandleInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImportSemaphoreWin32HandleInfo), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetSemaphoreWin32HandleKHR : {
			packet_vkGetSemaphoreWin32HandleKHR*  packet = BitCast<packet_vkGetSemaphoreWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetWin32HandleInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pGetWin32HandleInfo), header );
			UnpackPointer( INOUT packet->pHandle, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryHostPointerPropertiesEXT : {
			packet_vkGetMemoryHostPointerPropertiesEXT*  packet = BitCast<packet_vkGetMemoryHostPointerPropertiesEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pHostPointer, header );
			UnpackPointer( INOUT packet->pMemoryHostPointerProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryHostPointerProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateValidationCacheEXT : {
			packet_vkCreateValidationCacheEXT*  packet = BitCast<packet_vkCreateValidationCacheEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pValidationCache, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyValidationCacheEXT : {
			packet_vkDestroyValidationCacheEXT*  packet = BitCast<packet_vkDestroyValidationCacheEXT*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkMergeValidationCachesEXT : {
			packet_vkMergeValidationCachesEXT*  packet = BitCast<packet_vkMergeValidationCachesEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSrcCaches, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetValidationCacheDataEXT : {
			packet_vkGetValidationCacheDataEXT*  packet = BitCast<packet_vkGetValidationCacheDataEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDataSize, header );
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetShaderInfoAMD : {
			packet_vkGetShaderInfoAMD*  packet = BitCast<packet_vkGetShaderInfoAMD*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfoSize, header );
			UnpackPointer( INOUT packet->pInfo, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceQueue2 : {
			packet_vkGetDeviceQueue2*  packet = BitCast<packet_vkGetDeviceQueue2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueueInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pQueueInfo), header );
			UnpackPointer( INOUT packet->pQueue, header );
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateInstanceVersion : break;
		case VKTRACE_TPI_VK_vkGetDescriptorSetLayoutSupport : {
			packet_vkGetDescriptorSetLayoutSupport*  packet = BitCast<packet_vkGetDescriptorSetLayoutSupport*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			UnpackPointer( INOUT packet->pSupport, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSupport), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceGroupPresentCapabilitiesKHR : {
			packet_vkGetDeviceGroupPresentCapabilitiesKHR*  packet = BitCast<packet_vkGetDeviceGroupPresentCapabilitiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDeviceGroupPresentCapabilities, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pDeviceGroupPresentCapabilities), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceGroupSurfacePresentModesKHR : {
			packet_vkGetDeviceGroupSurfacePresentModesKHR*  packet = BitCast<packet_vkGetDeviceGroupSurfacePresentModesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pModes, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDevicePresentRectanglesKHR : {
			packet_vkGetPhysicalDevicePresentRectanglesKHR*  packet = BitCast<packet_vkGetPhysicalDevicePresentRectanglesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRectCount, header );
			UnpackPointer( INOUT packet->pRects, header );
			Unpack_VkRect2D( PtrCast<VkRect2D>(packet->pRects), header );
			break;
		}

		case VKTRACE_TPI_VK_vkAcquireNextImage2KHR : {
			packet_vkAcquireNextImage2KHR*  packet = BitCast<packet_vkAcquireNextImage2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAcquireInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pAcquireInfo), header );
			UnpackPointer( INOUT packet->pImageIndex, header );
			break;
		}

		case VKTRACE_TPI_VK_vkBindBufferMemory2 : {
			packet_vkBindBufferMemory2*  packet = BitCast<packet_vkBindBufferMemory2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfos, header );
			for (uint i = 0; (packet->pBindInfos != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pBindInfos + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkBindImageMemory2 : {
			packet_vkBindImageMemory2*  packet = BitCast<packet_vkBindImageMemory2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfos, header );
			for (uint i = 0; (packet->pBindInfos != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pBindInfos + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceGroupPeerMemoryFeatures : {
			packet_vkGetDeviceGroupPeerMemoryFeatures*  packet = BitCast<packet_vkGetDeviceGroupPeerMemoryFeatures*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPeerMemoryFeatures, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDeviceMask : {
			packet_vkCmdSetDeviceMask*  packet = BitCast<packet_vkCmdSetDeviceMask*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDispatchBase : {
			packet_vkCmdDispatchBase*  packet = BitCast<packet_vkCmdDispatchBase*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkEnumeratePhysicalDeviceGroups : {
			packet_vkEnumeratePhysicalDeviceGroups*  packet = BitCast<packet_vkEnumeratePhysicalDeviceGroups*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPhysicalDeviceGroupCount, header );
			UnpackPointer( INOUT packet->pPhysicalDeviceGroupProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pPhysicalDeviceGroupProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageMemoryRequirements2 : {
			packet_vkGetImageMemoryRequirements2*  packet = BitCast<packet_vkGetImageMemoryRequirements2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pInfo), header );
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetBufferMemoryRequirements2 : {
			packet_vkGetBufferMemoryRequirements2*  packet = BitCast<packet_vkGetBufferMemoryRequirements2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pInfo), header );
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageSparseMemoryRequirements2 : {
			packet_vkGetImageSparseMemoryRequirements2*  packet = BitCast<packet_vkGetImageSparseMemoryRequirements2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pInfo), header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirementCount, header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirements, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pSparseMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFeatures2 : {
			packet_vkGetPhysicalDeviceFeatures2*  packet = BitCast<packet_vkGetPhysicalDeviceFeatures2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFeatures, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pFeatures), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceProperties2 : {
			packet_vkGetPhysicalDeviceProperties2*  packet = BitCast<packet_vkGetPhysicalDeviceProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFormatProperties2 : {
			packet_vkGetPhysicalDeviceFormatProperties2*  packet = BitCast<packet_vkGetPhysicalDeviceFormatProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceImageFormatProperties2 : {
			packet_vkGetPhysicalDeviceImageFormatProperties2*  packet = BitCast<packet_vkGetPhysicalDeviceImageFormatProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImageFormatInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImageFormatInfo), header );
			UnpackPointer( INOUT packet->pImageFormatProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pImageFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceQueueFamilyProperties2 : {
			packet_vkGetPhysicalDeviceQueueFamilyProperties2*  packet = BitCast<packet_vkGetPhysicalDeviceQueueFamilyProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueueFamilyPropertyCount, header );
			UnpackPointer( INOUT packet->pQueueFamilyProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pQueueFamilyProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceMemoryProperties2 : {
			packet_vkGetPhysicalDeviceMemoryProperties2*  packet = BitCast<packet_vkGetPhysicalDeviceMemoryProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pMemoryProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSparseImageFormatProperties2 : {
			packet_vkGetPhysicalDeviceSparseImageFormatProperties2*  packet = BitCast<packet_vkGetPhysicalDeviceSparseImageFormatProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pFormatInfo), header );
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkTrimCommandPool : {
			packet_vkTrimCommandPool*  packet = BitCast<packet_vkTrimCommandPool*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSamplerYcbcrConversion : {
			packet_vkCreateSamplerYcbcrConversion*  packet = BitCast<packet_vkCreateSamplerYcbcrConversion*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pYcbcrConversion, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySamplerYcbcrConversion : {
			packet_vkDestroySamplerYcbcrConversion*  packet = BitCast<packet_vkDestroySamplerYcbcrConversion*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDescriptorUpdateTemplate : {
			packet_vkCreateDescriptorUpdateTemplate*  packet = BitCast<packet_vkCreateDescriptorUpdateTemplate*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCreateInfo), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pDescriptorUpdateTemplate, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDescriptorUpdateTemplate : {
			packet_vkDestroyDescriptorUpdateTemplate*  packet = BitCast<packet_vkDestroyDescriptorUpdateTemplate*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkUpdateDescriptorSetWithTemplate : {
			packet_vkUpdateDescriptorSetWithTemplate*  packet = BitCast<packet_vkUpdateDescriptorSetWithTemplate*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalBufferProperties : {
			packet_vkGetPhysicalDeviceExternalBufferProperties*  packet = BitCast<packet_vkGetPhysicalDeviceExternalBufferProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalBufferInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalBufferInfo), header );
			UnpackPointer( INOUT packet->pExternalBufferProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalBufferProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalFenceProperties : {
			packet_vkGetPhysicalDeviceExternalFenceProperties*  packet = BitCast<packet_vkGetPhysicalDeviceExternalFenceProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalFenceInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalFenceInfo), header );
			UnpackPointer( INOUT packet->pExternalFenceProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalFenceProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalSemaphoreProperties : {
			packet_vkGetPhysicalDeviceExternalSemaphoreProperties*  packet = BitCast<packet_vkGetPhysicalDeviceExternalSemaphoreProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalSemaphoreInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalSemaphoreInfo), header );
			UnpackPointer( INOUT packet->pExternalSemaphoreProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pExternalSemaphoreProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceDisplayProperties2KHR : {
			packet_vkGetPhysicalDeviceDisplayProperties2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceDisplayProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceDisplayPlaneProperties2KHR : {
			packet_vkGetPhysicalDeviceDisplayPlaneProperties2KHR*  packet = BitCast<packet_vkGetPhysicalDeviceDisplayPlaneProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayModeProperties2KHR : {
			packet_vkGetDisplayModeProperties2KHR*  packet = BitCast<packet_vkGetDisplayModeProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayPlaneCapabilities2KHR : {
			packet_vkGetDisplayPlaneCapabilities2KHR*  packet = BitCast<packet_vkGetDisplayPlaneCapabilities2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayPlaneInfo, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pDisplayPlaneInfo), header );
			UnpackPointer( INOUT packet->pCapabilities, header );
			UnpackStruct( PtrCast<VkBaseOutStructure>(packet->pCapabilities), header );
			break;
		}

	}
	DISABLE_ENUM_CHECKS();
}

