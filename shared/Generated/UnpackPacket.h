// auto-generated file

static void UnpackStruct (VkBaseOutStructure *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceSparseProperties (VkPhysicalDeviceSparseProperties *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorUpdateTemplateEntry (VkDescriptorUpdateTemplateEntry *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceLimits (VkPhysicalDeviceLimits *, vktrace_trace_packet_header *);
static void Unpack_VkImageFormatProperties (VkImageFormatProperties *, vktrace_trace_packet_header *);
static void Unpack_VkFormatProperties (VkFormatProperties *, vktrace_trace_packet_header *);
static void Unpack_VkPipelineColorBlendAttachmentState (VkPipelineColorBlendAttachmentState *, vktrace_trace_packet_header *);
static void Unpack_VkAllocationCallbacks (VkAllocationCallbacks *, vktrace_trace_packet_header *);
static void Unpack_VkSubresourceLayout (VkSubresourceLayout *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceFeatures (VkPhysicalDeviceFeatures *, vktrace_trace_packet_header *);
static void Unpack_VkExtent3D (VkExtent3D *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceProperties (VkPhysicalDeviceProperties *, vktrace_trace_packet_header *);
static void Unpack_VkSparseBufferMemoryBindInfo (VkSparseBufferMemoryBindInfo *, vktrace_trace_packet_header *);
static void Unpack_VkQueueFamilyProperties (VkQueueFamilyProperties *, vktrace_trace_packet_header *);
static void Unpack_VkMemoryType (VkMemoryType *, vktrace_trace_packet_header *);
static void Unpack_VkMemoryHeap (VkMemoryHeap *, vktrace_trace_packet_header *);
static void Unpack_VkPhysicalDeviceMemoryProperties (VkPhysicalDeviceMemoryProperties *, vktrace_trace_packet_header *);
static void Unpack_VkOffset2D (VkOffset2D *, vktrace_trace_packet_header *);
static void Unpack_VkSparseMemoryBind (VkSparseMemoryBind *, vktrace_trace_packet_header *);
static void Unpack_VkExtensionProperties (VkExtensionProperties *, vktrace_trace_packet_header *);
static void Unpack_VkLayerProperties (VkLayerProperties *, vktrace_trace_packet_header *);
static void Unpack_VkSpecializationMapEntry (VkSpecializationMapEntry *, vktrace_trace_packet_header *);
static void Unpack_VkComponentMapping (VkComponentMapping *, vktrace_trace_packet_header *);
static void Unpack_VkMemoryRequirements (VkMemoryRequirements *, vktrace_trace_packet_header *);
static void Unpack_VkImageResolve (VkImageResolve *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageFormatProperties (VkSparseImageFormatProperties *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageMemoryRequirements (VkSparseImageMemoryRequirements *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageOpaqueMemoryBindInfo (VkSparseImageOpaqueMemoryBindInfo *, vktrace_trace_packet_header *);
static void Unpack_VkImageSubresource (VkImageSubresource *, vktrace_trace_packet_header *);
static void Unpack_VkOffset3D (VkOffset3D *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageMemoryBind (VkSparseImageMemoryBind *, vktrace_trace_packet_header *);
static void Unpack_VkSparseImageMemoryBindInfo (VkSparseImageMemoryBindInfo *, vktrace_trace_packet_header *);
static void Unpack_VkViewport (VkViewport *, vktrace_trace_packet_header *);
static void Unpack_VkImageSubresourceRange (VkImageSubresourceRange *, vktrace_trace_packet_header *);
static void Unpack_VkSpecializationInfo (VkSpecializationInfo *, vktrace_trace_packet_header *);
static void Unpack_VkVertexInputBindingDescription (VkVertexInputBindingDescription *, vktrace_trace_packet_header *);
static void Unpack_VkImageCopy (VkImageCopy *, vktrace_trace_packet_header *);
static void Unpack_VkVertexInputAttributeDescription (VkVertexInputAttributeDescription *, vktrace_trace_packet_header *);
static void Unpack_VkExtent2D (VkExtent2D *, vktrace_trace_packet_header *);
static void Unpack_VkRect2D (VkRect2D *, vktrace_trace_packet_header *);
static void Unpack_VkStencilOpState (VkStencilOpState *, vktrace_trace_packet_header *);
static void Unpack_VkXYColorEXT (VkXYColorEXT *, vktrace_trace_packet_header *);
static void Unpack_VkPushConstantRange (VkPushConstantRange *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayPlanePropertiesKHR (VkDisplayPlanePropertiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorSetLayoutBinding (VkDescriptorSetLayoutBinding *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorPoolSize (VkDescriptorPoolSize *, vktrace_trace_packet_header *);
static void Unpack_VkClearValue (VkClearValue *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorImageInfo (VkDescriptorImageInfo *, vktrace_trace_packet_header *);
static void Unpack_VkDescriptorBufferInfo (VkDescriptorBufferInfo *, vktrace_trace_packet_header *);
static void Unpack_VkAttachmentDescription (VkAttachmentDescription *, vktrace_trace_packet_header *);
static void Unpack_VkAttachmentReference (VkAttachmentReference *, vktrace_trace_packet_header *);
static void Unpack_VkSubpassDescription (VkSubpassDescription *, vktrace_trace_packet_header *);
static void Unpack_VkSubpassDependency (VkSubpassDependency *, vktrace_trace_packet_header *);
static void Unpack_VkBufferCopy (VkBufferCopy *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayModePropertiesKHR (VkDisplayModePropertiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkImageSubresourceLayers (VkImageSubresourceLayers *, vktrace_trace_packet_header *);
static void Unpack_VkImageBlit (VkImageBlit *, vktrace_trace_packet_header *);
static void Unpack_VkBufferImageCopy (VkBufferImageCopy *, vktrace_trace_packet_header *);
static void Unpack_VkClearColorValue (VkClearColorValue *, vktrace_trace_packet_header *);
static void Unpack_VkClearDepthStencilValue (VkClearDepthStencilValue *, vktrace_trace_packet_header *);
static void Unpack_VkClearAttachment (VkClearAttachment *, vktrace_trace_packet_header *);
static void Unpack_VkClearRect (VkClearRect *, vktrace_trace_packet_header *);
static void Unpack_VkViewportSwizzleNV (VkViewportSwizzleNV *, vktrace_trace_packet_header *);
static void Unpack_VkShadingRatePaletteNV (VkShadingRatePaletteNV *, vktrace_trace_packet_header *);
static void Unpack_VkInputAttachmentAspectReference (VkInputAttachmentAspectReference *, vktrace_trace_packet_header *);
static void Unpack_VkExternalMemoryProperties (VkExternalMemoryProperties *, vktrace_trace_packet_header *);
static void Unpack_VkCoarseSampleLocationNV (VkCoarseSampleLocationNV *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayModeParametersKHR (VkDisplayModeParametersKHR *, vktrace_trace_packet_header *);
static void Unpack_VkSurfaceCapabilitiesKHR (VkSurfaceCapabilitiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkSurfaceFormatKHR (VkSurfaceFormatKHR *, vktrace_trace_packet_header *);
static void Unpack_VkExternalImageFormatPropertiesNV (VkExternalImageFormatPropertiesNV *, vktrace_trace_packet_header *);
static void Unpack_VkIndirectCommandsLayoutTokenNVX (VkIndirectCommandsLayoutTokenNVX *, vktrace_trace_packet_header *);
static void Unpack_VkVertexInputBindingDivisorDescriptionEXT (VkVertexInputBindingDivisorDescriptionEXT *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayPropertiesKHR (VkDisplayPropertiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkDisplayPlaneCapabilitiesKHR (VkDisplayPlaneCapabilitiesKHR *, vktrace_trace_packet_header *);
static void Unpack_VkSubpassSampleLocationsEXT (VkSubpassSampleLocationsEXT *, vktrace_trace_packet_header *);
static void Unpack_VkRectLayerKHR (VkRectLayerKHR *, vktrace_trace_packet_header *);
static void Unpack_VkPresentRegionKHR (VkPresentRegionKHR *, vktrace_trace_packet_header *);
static void Unpack_VkConformanceVersionKHR (VkConformanceVersionKHR *, vktrace_trace_packet_header *);
static void Unpack_VkCoarseSampleOrderCustomNV (VkCoarseSampleOrderCustomNV *, vktrace_trace_packet_header *);
static void Unpack_VkIndirectCommandsTokenNVX (VkIndirectCommandsTokenNVX *, vktrace_trace_packet_header *);
static void Unpack_VkObjectTableEntryNVX (VkObjectTableEntryNVX *, vktrace_trace_packet_header *);
static void Unpack_VkViewportWScalingNV (VkViewportWScalingNV *, vktrace_trace_packet_header *);
static void Unpack_VkRefreshCycleDurationGOOGLE (VkRefreshCycleDurationGOOGLE *, vktrace_trace_packet_header *);
static void Unpack_VkPastPresentationTimingGOOGLE (VkPastPresentationTimingGOOGLE *, vktrace_trace_packet_header *);
static void Unpack_VkDrmFormatModifierPropertiesEXT (VkDrmFormatModifierPropertiesEXT *, vktrace_trace_packet_header *);
static void Unpack_VkPresentTimeGOOGLE (VkPresentTimeGOOGLE *, vktrace_trace_packet_header *);
static void Unpack_VkSampleLocationEXT (VkSampleLocationEXT *, vktrace_trace_packet_header *);
static void Unpack_VkAttachmentSampleLocationsEXT (VkAttachmentSampleLocationsEXT *, vktrace_trace_packet_header *);
static void Unpack_VkGeometryDataNV (VkGeometryDataNV *, vktrace_trace_packet_header *);
//-----------------------------------------------------------------------------

static void UnpackStruct (VkBaseOutStructure *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pNext, header );
	UnpackStruct( ptr->pNext, header );

	ENABLE_ENUM_CHECKS();
	switch ( ptr->sType )
	{
		case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO : {
			VkDeviceCreateInfo*  value = BitCast<VkDeviceCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pQueueCreateInfos, header );
			for (uint i = 0; (value->pQueueCreateInfos != null) and (i < value->queueCreateInfoCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDeviceQueueCreateInfo*>(value->pQueueCreateInfos + i)), header );
			}
			UnpackPointer( INOUT value->ppEnabledLayerNames, header );
			for (uint i = 0; (value->ppEnabledLayerNames != null) and (i < value->enabledLayerCount); ++i) {
				UnpackPointer( INOUT value->ppEnabledLayerNames[i], header );
			}
			UnpackPointer( INOUT value->ppEnabledExtensionNames, header );
			for (uint i = 0; (value->ppEnabledExtensionNames != null) and (i < value->enabledExtensionCount); ++i) {
				UnpackPointer( INOUT value->ppEnabledExtensionNames[i], header );
			}
			UnpackPointer( INOUT value->pEnabledFeatures, header );
			Unpack_VkPhysicalDeviceFeatures( const_cast<VkPhysicalDeviceFeatures*>(value->pEnabledFeatures), header );
			break;
		}

		case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES : {
			VkExternalImageFormatProperties*  value = BitCast<VkExternalImageFormatProperties*>( ptr );
			Unpack_VkExternalMemoryProperties( &value->externalMemoryProperties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV : {
			VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*  value = BitCast<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pCustomSampleOrders, header );
			for (uint i = 0; (value->pCustomSampleOrders != null) and (i < value->customSampleOrderCount); ++i) {
				Unpack_VkCoarseSampleOrderCustomNV( const_cast<VkCoarseSampleOrderCustomNV*>(value->pCustomSampleOrders + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_APPLICATION_INFO : {
			VkApplicationInfo*  value = BitCast<VkApplicationInfo*>( ptr );
			UnpackPointer( INOUT value->pApplicationName, header );
			UnpackPointer( INOUT value->pEngineName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT : {
			VkDebugUtilsObjectNameInfoEXT*  value = BitCast<VkDebugUtilsObjectNameInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pObjectName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO : {
			VkInstanceCreateInfo*  value = BitCast<VkInstanceCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pApplicationInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkApplicationInfo*>(value->pApplicationInfo)), header );
			UnpackPointer( INOUT value->ppEnabledLayerNames, header );
			for (uint i = 0; (value->ppEnabledLayerNames != null) and (i < value->enabledLayerCount); ++i) {
				UnpackPointer( INOUT value->ppEnabledLayerNames[i], header );
			}
			UnpackPointer( INOUT value->ppEnabledExtensionNames, header );
			for (uint i = 0; (value->ppEnabledExtensionNames != null) and (i < value->enabledExtensionCount); ++i) {
				UnpackPointer( INOUT value->ppEnabledExtensionNames[i], header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT : {
			VkValidationCacheCreateInfoEXT*  value = BitCast<VkValidationCacheCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pInitialData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR : {
			VkImageFormatListCreateInfoKHR*  value = BitCast<VkImageFormatListCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pViewFormats, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO : {
			VkDeviceQueueCreateInfo*  value = BitCast<VkDeviceQueueCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pQueuePriorities, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SUBMIT_INFO : {
			VkSubmitInfo*  value = BitCast<VkSubmitInfo*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphores, header );
			UnpackPointer( INOUT value->pWaitDstStageMask, header );
			UnpackPointer( INOUT value->pCommandBuffers, header );
			UnpackPointer( INOUT value->pSignalSemaphores, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO : {
			VkPipelineDynamicStateCreateInfo*  value = BitCast<VkPipelineDynamicStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pDynamicStates, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO : {
			VkImageViewCreateInfo*  value = BitCast<VkImageViewCreateInfo*>( ptr );
			Unpack_VkComponentMapping( &value->components, header );
			Unpack_VkImageSubresourceRange( &value->subresourceRange, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT : {
			VkImportMemoryHostPointerInfoEXT*  value = BitCast<VkImportMemoryHostPointerInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pHostPointer, header );
			break;
		}

		case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO : {
			VkBindSparseInfo*  value = BitCast<VkBindSparseInfo*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphores, header );
			UnpackPointer( INOUT value->pBufferBinds, header );
			for (uint i = 0; (value->pBufferBinds != null) and (i < value->bufferBindCount); ++i) {
				Unpack_VkSparseBufferMemoryBindInfo( const_cast<VkSparseBufferMemoryBindInfo*>(value->pBufferBinds + i), header );
			}
			UnpackPointer( INOUT value->pImageOpaqueBinds, header );
			for (uint i = 0; (value->pImageOpaqueBinds != null) and (i < value->imageOpaqueBindCount); ++i) {
				Unpack_VkSparseImageOpaqueMemoryBindInfo( const_cast<VkSparseImageOpaqueMemoryBindInfo*>(value->pImageOpaqueBinds + i), header );
			}
			UnpackPointer( INOUT value->pImageBinds, header );
			for (uint i = 0; (value->pImageBinds != null) and (i < value->imageBindCount); ++i) {
				Unpack_VkSparseImageMemoryBindInfo( const_cast<VkSparseImageMemoryBindInfo*>(value->pImageBinds + i), header );
			}
			UnpackPointer( INOUT value->pSignalSemaphores, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO : {
			VkPipelineViewportStateCreateInfo*  value = BitCast<VkPipelineViewportStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pViewports, header );
			for (uint i = 0; (value->pViewports != null) and (i < value->viewportCount); ++i) {
				Unpack_VkViewport( const_cast<VkViewport*>(value->pViewports + i), header );
			}
			UnpackPointer( INOUT value->pScissors, header );
			for (uint i = 0; (value->pScissors != null) and (i < value->scissorCount); ++i) {
				Unpack_VkRect2D( const_cast<VkRect2D*>(value->pScissors + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV : {
			VkAccelerationStructureInfoNV*  value = BitCast<VkAccelerationStructureInfoNV*>( ptr );
			UnpackPointer( INOUT value->pGeometries, header );
			for (uint i = 0; (value->pGeometries != null) and (i < value->geometryCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkGeometryNV*>(value->pGeometries + i)), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO : {
			VkPipelineVertexInputStateCreateInfo*  value = BitCast<VkPipelineVertexInputStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pVertexBindingDescriptions, header );
			for (uint i = 0; (value->pVertexBindingDescriptions != null) and (i < value->vertexBindingDescriptionCount); ++i) {
				Unpack_VkVertexInputBindingDescription( const_cast<VkVertexInputBindingDescription*>(value->pVertexBindingDescriptions + i), header );
			}
			UnpackPointer( INOUT value->pVertexAttributeDescriptions, header );
			for (uint i = 0; (value->pVertexAttributeDescriptions != null) and (i < value->vertexAttributeDescriptionCount); ++i) {
				Unpack_VkVertexInputAttributeDescription( const_cast<VkVertexInputAttributeDescription*>(value->pVertexAttributeDescriptions + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkExportSemaphoreWin32HandleInfoKHR*  value = BitCast<VkExportSemaphoreWin32HandleInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pAttributes, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO : {
			VkRenderPassBeginInfo*  value = BitCast<VkRenderPassBeginInfo*>( ptr );
			Unpack_VkRect2D( &value->renderArea, header );
			UnpackPointer( INOUT value->pClearValues, header );
			for (uint i = 0; (value->pClearValues != null) and (i < value->clearValueCount); ++i) {
				Unpack_VkClearValue( const_cast<VkClearValue*>(value->pClearValues + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO : {
			VkBufferCreateInfo*  value = BitCast<VkBufferCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pQueueFamilyIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO : {
			VkImageCreateInfo*  value = BitCast<VkImageCreateInfo*>( ptr );
			Unpack_VkExtent3D( &value->extent, header );
			UnpackPointer( INOUT value->pQueueFamilyIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO : {
			VkPipelineMultisampleStateCreateInfo*  value = BitCast<VkPipelineMultisampleStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pSampleMask, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO : {
			VkShaderModuleCreateInfo*  value = BitCast<VkShaderModuleCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pCode, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT : {
			VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*  value = BitCast<VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pBindingFlags, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO : {
			VkPipelineCacheCreateInfo*  value = BitCast<VkPipelineCacheCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pInitialData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO : {
			VkPipelineShaderStageCreateInfo*  value = BitCast<VkPipelineShaderStageCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pName, header );
			UnpackPointer( INOUT value->pSpecializationInfo, header );
			Unpack_VkSpecializationInfo( const_cast<VkSpecializationInfo*>(value->pSpecializationInfo), header );
			break;
		}

		case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE : {
			VkPresentTimesInfoGOOGLE*  value = BitCast<VkPresentTimesInfoGOOGLE*>( ptr );
			UnpackPointer( INOUT value->pTimes, header );
			for (uint i = 0; (value->pTimes != null) and (i < value->swapchainCount); ++i) {
				Unpack_VkPresentTimeGOOGLE( const_cast<VkPresentTimeGOOGLE*>(value->pTimes + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO : {
			VkPipelineDepthStencilStateCreateInfo*  value = BitCast<VkPipelineDepthStencilStateCreateInfo*>( ptr );
			Unpack_VkStencilOpState( &value->front, header );
			Unpack_VkStencilOpState( &value->back, header );
			break;
		}

		case VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR : {
			#ifdef VULKAN_ANDROID_H_
			VkAndroidSurfaceCreateInfoKHR*  value = BitCast<VkAndroidSurfaceCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->window, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO : {
			VkPipelineColorBlendStateCreateInfo*  value = BitCast<VkPipelineColorBlendStateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pAttachments, header );
			for (uint i = 0; (value->pAttachments != null) and (i < value->attachmentCount); ++i) {
				Unpack_VkPipelineColorBlendAttachmentState( const_cast<VkPipelineColorBlendAttachmentState*>(value->pAttachments + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO : {
			VkGraphicsPipelineCreateInfo*  value = BitCast<VkGraphicsPipelineCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pStages, header );
			for (uint i = 0; (value->pStages != null) and (i < value->stageCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineShaderStageCreateInfo*>(value->pStages + i)), header );
			}
			UnpackPointer( INOUT value->pVertexInputState, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineVertexInputStateCreateInfo*>(value->pVertexInputState)), header );
			UnpackPointer( INOUT value->pInputAssemblyState, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineInputAssemblyStateCreateInfo*>(value->pInputAssemblyState)), header );
			UnpackPointer( INOUT value->pTessellationState, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineTessellationStateCreateInfo*>(value->pTessellationState)), header );
			UnpackPointer( INOUT value->pViewportState, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineViewportStateCreateInfo*>(value->pViewportState)), header );
			UnpackPointer( INOUT value->pRasterizationState, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineRasterizationStateCreateInfo*>(value->pRasterizationState)), header );
			UnpackPointer( INOUT value->pMultisampleState, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineMultisampleStateCreateInfo*>(value->pMultisampleState)), header );
			UnpackPointer( INOUT value->pDepthStencilState, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineDepthStencilStateCreateInfo*>(value->pDepthStencilState)), header );
			UnpackPointer( INOUT value->pColorBlendState, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineColorBlendStateCreateInfo*>(value->pColorBlendState)), header );
			UnpackPointer( INOUT value->pDynamicState, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineDynamicStateCreateInfo*>(value->pDynamicState)), header );
			break;
		}

		case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO : {
			VkComputePipelineCreateInfo*  value = BitCast<VkComputePipelineCreateInfo*>( ptr );
			UnpackStruct( BitCast<VkBaseOutStructure*>(&value->stage), header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO : {
			VkPipelineLayoutCreateInfo*  value = BitCast<VkPipelineLayoutCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pSetLayouts, header );
			UnpackPointer( INOUT value->pPushConstantRanges, header );
			for (uint i = 0; (value->pPushConstantRanges != null) and (i < value->pushConstantRangeCount); ++i) {
				Unpack_VkPushConstantRange( const_cast<VkPushConstantRange*>(value->pPushConstantRanges + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR : {
			VkDisplayPlaneProperties2KHR*  value = BitCast<VkDisplayPlaneProperties2KHR*>( ptr );
			Unpack_VkDisplayPlanePropertiesKHR( &value->displayPlaneProperties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR : {
			VkDisplayPresentInfoKHR*  value = BitCast<VkDisplayPresentInfoKHR*>( ptr );
			Unpack_VkRect2D( &value->srcRect, header );
			Unpack_VkRect2D( &value->dstRect, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO : {
			VkDescriptorSetLayoutCreateInfo*  value = BitCast<VkDescriptorSetLayoutCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pBindings, header );
			for (uint i = 0; (value->pBindings != null) and (i < value->bindingCount); ++i) {
				Unpack_VkDescriptorSetLayoutBinding( const_cast<VkDescriptorSetLayoutBinding*>(value->pBindings + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO : {
			VkDescriptorPoolCreateInfo*  value = BitCast<VkDescriptorPoolCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pPoolSizes, header );
			for (uint i = 0; (value->pPoolSizes != null) and (i < value->poolSizeCount); ++i) {
				Unpack_VkDescriptorPoolSize( const_cast<VkDescriptorPoolSize*>(value->pPoolSizes + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO : {
			VkDescriptorSetAllocateInfo*  value = BitCast<VkDescriptorSetAllocateInfo*>( ptr );
			UnpackPointer( INOUT value->pSetLayouts, header );
			break;
		}

		case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV : {
			#ifdef VULKAN_WIN32_H_
			VkExportMemoryWin32HandleInfoNV*  value = BitCast<VkExportMemoryWin32HandleInfoNV*>( ptr );
			UnpackPointer( INOUT value->pAttributes, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_HDR_METADATA_EXT : {
			VkHdrMetadataEXT*  value = BitCast<VkHdrMetadataEXT*>( ptr );
			Unpack_VkXYColorEXT( &value->displayPrimaryRed, header );
			Unpack_VkXYColorEXT( &value->displayPrimaryGreen, header );
			Unpack_VkXYColorEXT( &value->displayPrimaryBlue, header );
			Unpack_VkXYColorEXT( &value->whitePoint, header );
			break;
		}

		case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET : {
			VkWriteDescriptorSet*  value = BitCast<VkWriteDescriptorSet*>( ptr );
			UnpackPointer( INOUT value->pImageInfo, header );
			for (uint i = 0; (value->pImageInfo != null) and (i < value->descriptorCount); ++i) {
				Unpack_VkDescriptorImageInfo( const_cast<VkDescriptorImageInfo*>(value->pImageInfo + i), header );
			}
			UnpackPointer( INOUT value->pBufferInfo, header );
			for (uint i = 0; (value->pBufferInfo != null) and (i < value->descriptorCount); ++i) {
				Unpack_VkDescriptorBufferInfo( const_cast<VkDescriptorBufferInfo*>(value->pBufferInfo + i), header );
			}
			UnpackPointer( INOUT value->pTexelBufferView, header );
			break;
		}

		case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO : {
			VkFramebufferCreateInfo*  value = BitCast<VkFramebufferCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pAttachments, header );
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO : {
			VkRenderPassCreateInfo*  value = BitCast<VkRenderPassCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pAttachments, header );
			for (uint i = 0; (value->pAttachments != null) and (i < value->attachmentCount); ++i) {
				Unpack_VkAttachmentDescription( const_cast<VkAttachmentDescription*>(value->pAttachments + i), header );
			}
			UnpackPointer( INOUT value->pSubpasses, header );
			for (uint i = 0; (value->pSubpasses != null) and (i < value->subpassCount); ++i) {
				Unpack_VkSubpassDescription( const_cast<VkSubpassDescription*>(value->pSubpasses + i), header );
			}
			UnpackPointer( INOUT value->pDependencies, header );
			for (uint i = 0; (value->pDependencies != null) and (i < value->dependencyCount); ++i) {
				Unpack_VkSubpassDependency( const_cast<VkSubpassDependency*>(value->pDependencies + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO : {
			VkCommandBufferBeginInfo*  value = BitCast<VkCommandBufferBeginInfo*>( ptr );
			UnpackPointer( INOUT value->pInheritanceInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkCommandBufferInheritanceInfo*>(value->pInheritanceInfo)), header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER : {
			VkImageMemoryBarrier*  value = BitCast<VkImageMemoryBarrier*>( ptr );
			Unpack_VkImageSubresourceRange( &value->subresourceRange, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV : {
			VkPhysicalDeviceShadingRateImagePropertiesNV*  value = BitCast<VkPhysicalDeviceShadingRateImagePropertiesNV*>( ptr );
			Unpack_VkExtent2D( &value->shadingRateTexelSize, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT : {
			VkImageDrmFormatModifierExplicitCreateInfoEXT*  value = BitCast<VkImageDrmFormatModifierExplicitCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pPlaneLayouts, header );
			for (uint i = 0; (value->pPlaneLayouts != null) and (i < value->drmFormatModifierPlaneCount); ++i) {
				Unpack_VkSubresourceLayout( const_cast<VkSubresourceLayout*>(value->pPlaneLayouts + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO : {
			VkDeviceGroupRenderPassBeginInfo*  value = BitCast<VkDeviceGroupRenderPassBeginInfo*>( ptr );
			UnpackPointer( INOUT value->pDeviceRenderAreas, header );
			for (uint i = 0; (value->pDeviceRenderAreas != null) and (i < value->deviceRenderAreaCount); ++i) {
				Unpack_VkRect2D( const_cast<VkRect2D*>(value->pDeviceRenderAreas + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO : {
			VkDeviceGroupSubmitInfo*  value = BitCast<VkDeviceGroupSubmitInfo*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphoreDeviceIndices, header );
			UnpackPointer( INOUT value->pCommandBufferDeviceMasks, header );
			UnpackPointer( INOUT value->pSignalSemaphoreDeviceIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO : {
			VkBindBufferMemoryDeviceGroupInfo*  value = BitCast<VkBindBufferMemoryDeviceGroupInfo*>( ptr );
			UnpackPointer( INOUT value->pDeviceIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO : {
			VkBindImageMemoryDeviceGroupInfo*  value = BitCast<VkBindImageMemoryDeviceGroupInfo*>( ptr );
			UnpackPointer( INOUT value->pDeviceIndices, header );
			UnpackPointer( INOUT value->pSplitInstanceBindRegions, header );
			for (uint i = 0; (value->pSplitInstanceBindRegions != null) and (i < value->splitInstanceBindRegionCount); ++i) {
				Unpack_VkRect2D( const_cast<VkRect2D*>(value->pSplitInstanceBindRegions + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO : {
			VkDeviceGroupDeviceCreateInfo*  value = BitCast<VkDeviceGroupDeviceCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pPhysicalDevices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 : {
			VkMemoryRequirements2*  value = BitCast<VkMemoryRequirements2*>( ptr );
			Unpack_VkMemoryRequirements( &value->memoryRequirements, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 : {
			VkSparseImageMemoryRequirements2*  value = BitCast<VkSparseImageMemoryRequirements2*>( ptr );
			Unpack_VkSparseImageMemoryRequirements( &value->memoryRequirements, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 : {
			VkPhysicalDeviceFeatures2*  value = BitCast<VkPhysicalDeviceFeatures2*>( ptr );
			Unpack_VkPhysicalDeviceFeatures( &value->features, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 : {
			VkPhysicalDeviceProperties2*  value = BitCast<VkPhysicalDeviceProperties2*>( ptr );
			Unpack_VkPhysicalDeviceProperties( &value->properties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 : {
			VkFormatProperties2*  value = BitCast<VkFormatProperties2*>( ptr );
			Unpack_VkFormatProperties( &value->formatProperties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 : {
			VkImageFormatProperties2*  value = BitCast<VkImageFormatProperties2*>( ptr );
			Unpack_VkImageFormatProperties( &value->imageFormatProperties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 : {
			VkQueueFamilyProperties2*  value = BitCast<VkQueueFamilyProperties2*>( ptr );
			Unpack_VkQueueFamilyProperties( &value->queueFamilyProperties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 : {
			VkPhysicalDeviceMemoryProperties2*  value = BitCast<VkPhysicalDeviceMemoryProperties2*>( ptr );
			Unpack_VkPhysicalDeviceMemoryProperties( &value->memoryProperties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 : {
			VkSparseImageFormatProperties2*  value = BitCast<VkSparseImageFormatProperties2*>( ptr );
			Unpack_VkSparseImageFormatProperties( &value->properties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO : {
			VkRenderPassInputAttachmentAspectCreateInfo*  value = BitCast<VkRenderPassInputAttachmentAspectCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pAspectReferences, header );
			for (uint i = 0; (value->pAspectReferences != null) and (i < value->aspectReferenceCount); ++i) {
				Unpack_VkInputAttachmentAspectReference( const_cast<VkInputAttachmentAspectReference*>(value->pAspectReferences + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO : {
			VkRenderPassMultiviewCreateInfo*  value = BitCast<VkRenderPassMultiviewCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pViewMasks, header );
			UnpackPointer( INOUT value->pViewOffsets, header );
			UnpackPointer( INOUT value->pCorrelationMasks, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR : {
			VkDisplayModeCreateInfoKHR*  value = BitCast<VkDisplayModeCreateInfoKHR*>( ptr );
			Unpack_VkDisplayModeParametersKHR( &value->parameters, header );
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT : {
			VkRenderPassSampleLocationsBeginInfoEXT*  value = BitCast<VkRenderPassSampleLocationsBeginInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pAttachmentInitialSampleLocations, header );
			for (uint i = 0; (value->pAttachmentInitialSampleLocations != null) and (i < value->attachmentInitialSampleLocationsCount); ++i) {
				Unpack_VkAttachmentSampleLocationsEXT( const_cast<VkAttachmentSampleLocationsEXT*>(value->pAttachmentInitialSampleLocations + i), header );
			}
			UnpackPointer( INOUT value->pPostSubpassSampleLocations, header );
			for (uint i = 0; (value->pPostSubpassSampleLocations != null) and (i < value->postSubpassSampleLocationsCount); ++i) {
				Unpack_VkSubpassSampleLocationsEXT( const_cast<VkSubpassSampleLocationsEXT*>(value->pPostSubpassSampleLocations + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO : {
			VkSamplerYcbcrConversionCreateInfo*  value = BitCast<VkSamplerYcbcrConversionCreateInfo*>( ptr );
			Unpack_VkComponentMapping( &value->components, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO : {
			VkDescriptorUpdateTemplateCreateInfo*  value = BitCast<VkDescriptorUpdateTemplateCreateInfo*>( ptr );
			UnpackPointer( INOUT value->pDescriptorUpdateEntries, header );
			for (uint i = 0; (value->pDescriptorUpdateEntries != null) and (i < value->descriptorUpdateEntryCount); ++i) {
				Unpack_VkDescriptorUpdateTemplateEntry( const_cast<VkDescriptorUpdateTemplateEntry*>(value->pDescriptorUpdateEntries + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES : {
			VkExternalBufferProperties*  value = BitCast<VkExternalBufferProperties*>( ptr );
			Unpack_VkExternalMemoryProperties( &value->externalMemoryProperties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkExportMemoryWin32HandleInfoKHR*  value = BitCast<VkExportMemoryWin32HandleInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pAttributes, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR : {
			VkSwapchainCreateInfoKHR*  value = BitCast<VkSwapchainCreateInfoKHR*>( ptr );
			Unpack_VkExtent2D( &value->imageExtent, header );
			UnpackPointer( INOUT value->pQueueFamilyIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR : {
			VkPresentInfoKHR*  value = BitCast<VkPresentInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphores, header );
			UnpackPointer( INOUT value->pSwapchains, header );
			UnpackPointer( INOUT value->pImageIndices, header );
			UnpackPointer( INOUT value->pResults, header );
			break;
		}

		case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV : {
			#ifdef VULKAN_WIN32_H_
			VkWin32KeyedMutexAcquireReleaseInfoNV*  value = BitCast<VkWin32KeyedMutexAcquireReleaseInfoNV*>( ptr );
			UnpackPointer( INOUT value->pAcquireSyncs, header );
			UnpackPointer( INOUT value->pAcquireKeys, header );
			UnpackPointer( INOUT value->pAcquireTimeoutMilliseconds, header );
			UnpackPointer( INOUT value->pReleaseSyncs, header );
			UnpackPointer( INOUT value->pReleaseKeys, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR : {
			VkDeviceGroupPresentInfoKHR*  value = BitCast<VkDeviceGroupPresentInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pDeviceMasks, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR : {
			VkDisplaySurfaceCreateInfoKHR*  value = BitCast<VkDisplaySurfaceCreateInfoKHR*>( ptr );
			Unpack_VkExtent2D( &value->imageExtent, header );
			break;
		}

		case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR : {
			#ifdef VULKAN_XCB_H_
			VkXcbSurfaceCreateInfoKHR*  value = BitCast<VkXcbSurfaceCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->connection, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR : {
			VkPresentRegionsKHR*  value = BitCast<VkPresentRegionsKHR*>( ptr );
			UnpackPointer( INOUT value->pRegions, header );
			for (uint i = 0; (value->pRegions != null) and (i < value->swapchainCount); ++i) {
				Unpack_VkPresentRegionKHR( const_cast<VkPresentRegionKHR*>(value->pRegions + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR : {
			VkSubpassDescription2KHR*  value = BitCast<VkSubpassDescription2KHR*>( ptr );
			UnpackPointer( INOUT value->pInputAttachments, header );
			for (uint i = 0; (value->pInputAttachments != null) and (i < value->inputAttachmentCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkAttachmentReference2KHR*>(value->pInputAttachments + i)), header );
			}
			UnpackPointer( INOUT value->pColorAttachments, header );
			for (uint i = 0; (value->pColorAttachments != null) and (i < value->colorAttachmentCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkAttachmentReference2KHR*>(value->pColorAttachments + i)), header );
			}
			UnpackPointer( INOUT value->pResolveAttachments, header );
			for (uint i = 0; (value->pResolveAttachments != null) and (i < value->colorAttachmentCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkAttachmentReference2KHR*>(value->pResolveAttachments + i)), header );
			}
			UnpackPointer( INOUT value->pDepthStencilAttachment, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkAttachmentReference2KHR*>(value->pDepthStencilAttachment)), header );
			UnpackPointer( INOUT value->pPreserveAttachments, header );
			break;
		}

		case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR : {
			VkRenderPassCreateInfo2KHR*  value = BitCast<VkRenderPassCreateInfo2KHR*>( ptr );
			UnpackPointer( INOUT value->pAttachments, header );
			for (uint i = 0; (value->pAttachments != null) and (i < value->attachmentCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkAttachmentDescription2KHR*>(value->pAttachments + i)), header );
			}
			UnpackPointer( INOUT value->pSubpasses, header );
			for (uint i = 0; (value->pSubpasses != null) and (i < value->subpassCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSubpassDescription2KHR*>(value->pSubpasses + i)), header );
			}
			UnpackPointer( INOUT value->pDependencies, header );
			for (uint i = 0; (value->pDependencies != null) and (i < value->dependencyCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSubpassDependency2KHR*>(value->pDependencies + i)), header );
			}
			UnpackPointer( INOUT value->pCorrelatedViewMasks, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT : {
			VkSurfaceCapabilities2EXT*  value = BitCast<VkSurfaceCapabilities2EXT*>( ptr );
			Unpack_VkExtent2D( &value->currentExtent, header );
			Unpack_VkExtent2D( &value->minImageExtent, header );
			Unpack_VkExtent2D( &value->maxImageExtent, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR : {
			VkSurfaceCapabilities2KHR*  value = BitCast<VkSurfaceCapabilities2KHR*>( ptr );
			Unpack_VkSurfaceCapabilitiesKHR( &value->surfaceCapabilities, header );
			break;
		}

		case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR : {
			VkSurfaceFormat2KHR*  value = BitCast<VkSurfaceFormat2KHR*>( ptr );
			Unpack_VkSurfaceFormatKHR( &value->surfaceFormat, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR : {
			VkDisplayProperties2KHR*  value = BitCast<VkDisplayProperties2KHR*>( ptr );
			Unpack_VkDisplayPropertiesKHR( &value->displayProperties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR : {
			VkDisplayModeProperties2KHR*  value = BitCast<VkDisplayModeProperties2KHR*>( ptr );
			Unpack_VkDisplayModePropertiesKHR( &value->displayModeProperties, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR : {
			VkDisplayPlaneCapabilities2KHR*  value = BitCast<VkDisplayPlaneCapabilities2KHR*>( ptr );
			Unpack_VkDisplayPlaneCapabilitiesKHR( &value->capabilities, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT : {
			VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*  value = BitCast<VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pDescriptorCounts, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR : {
			VkPhysicalDeviceDriverPropertiesKHR*  value = BitCast<VkPhysicalDeviceDriverPropertiesKHR*>( ptr );
			Unpack_VkConformanceVersionKHR( &value->conformanceVersion, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT : {
			VkDebugReportCallbackCreateInfoEXT*  value = BitCast<VkDebugReportCallbackCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pUserData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT : {
			VkDebugMarkerObjectNameInfoEXT*  value = BitCast<VkDebugMarkerObjectNameInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pObjectName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT : {
			VkDebugMarkerObjectTagInfoEXT*  value = BitCast<VkDebugMarkerObjectTagInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pTag, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT : {
			VkDebugMarkerMarkerInfoEXT*  value = BitCast<VkDebugMarkerMarkerInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pMarkerName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT : {
			VkValidationFlagsEXT*  value = BitCast<VkValidationFlagsEXT*>( ptr );
			UnpackPointer( INOUT value->pDisabledValidationChecks, header );
			break;
		}

		case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkD3D12FenceSubmitInfoKHR*  value = BitCast<VkD3D12FenceSubmitInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pWaitSemaphoreValues, header );
			UnpackPointer( INOUT value->pSignalSemaphoreValues, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX : {
			VkIndirectCommandsLayoutCreateInfoNVX*  value = BitCast<VkIndirectCommandsLayoutCreateInfoNVX*>( ptr );
			UnpackPointer( INOUT value->pTokens, header );
			for (uint i = 0; (value->pTokens != null) and (i < value->tokenCount); ++i) {
				Unpack_VkIndirectCommandsLayoutTokenNVX( const_cast<VkIndirectCommandsLayoutTokenNVX*>(value->pTokens + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX : {
			VkCmdProcessCommandsInfoNVX*  value = BitCast<VkCmdProcessCommandsInfoNVX*>( ptr );
			UnpackPointer( INOUT value->pIndirectCommandsTokens, header );
			for (uint i = 0; (value->pIndirectCommandsTokens != null) and (i < value->indirectCommandsTokenCount); ++i) {
				Unpack_VkIndirectCommandsTokenNVX( const_cast<VkIndirectCommandsTokenNVX*>(value->pIndirectCommandsTokens + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX : {
			VkObjectTableCreateInfoNVX*  value = BitCast<VkObjectTableCreateInfoNVX*>( ptr );
			UnpackPointer( INOUT value->pObjectEntryTypes, header );
			UnpackPointer( INOUT value->pObjectEntryCounts, header );
			UnpackPointer( INOUT value->pObjectEntryUsageFlags, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV : {
			VkPipelineViewportExclusiveScissorStateCreateInfoNV*  value = BitCast<VkPipelineViewportExclusiveScissorStateCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pExclusiveScissors, header );
			for (uint i = 0; (value->pExclusiveScissors != null) and (i < value->exclusiveScissorCount); ++i) {
				Unpack_VkRect2D( const_cast<VkRect2D*>(value->pExclusiveScissors + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV : {
			VkPipelineViewportWScalingStateCreateInfoNV*  value = BitCast<VkPipelineViewportWScalingStateCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pViewportWScalings, header );
			for (uint i = 0; (value->pViewportWScalings != null) and (i < value->viewportCount); ++i) {
				Unpack_VkViewportWScalingNV( const_cast<VkViewportWScalingNV*>(value->pViewportWScalings + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV : {
			VkPipelineViewportSwizzleStateCreateInfoNV*  value = BitCast<VkPipelineViewportSwizzleStateCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pViewportSwizzles, header );
			for (uint i = 0; (value->pViewportSwizzles != null) and (i < value->viewportCount); ++i) {
				Unpack_VkViewportSwizzleNV( const_cast<VkViewportSwizzleNV*>(value->pViewportSwizzles + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT : {
			VkPipelineDiscardRectangleStateCreateInfoEXT*  value = BitCast<VkPipelineDiscardRectangleStateCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pDiscardRectangles, header );
			for (uint i = 0; (value->pDiscardRectangles != null) and (i < value->discardRectangleCount); ++i) {
				Unpack_VkRect2D( const_cast<VkRect2D*>(value->pDiscardRectangles + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT : {
			VkDebugUtilsObjectTagInfoEXT*  value = BitCast<VkDebugUtilsObjectTagInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pTag, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT : {
			VkDebugUtilsLabelEXT*  value = BitCast<VkDebugUtilsLabelEXT*>( ptr );
			UnpackPointer( INOUT value->pLabelName, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT : {
			VkDebugUtilsMessengerCallbackDataEXT*  value = BitCast<VkDebugUtilsMessengerCallbackDataEXT*>( ptr );
			UnpackPointer( INOUT value->pMessageIdName, header );
			UnpackPointer( INOUT value->pMessage, header );
			UnpackPointer( INOUT value->pQueueLabels, header );
			for (uint i = 0; (value->pQueueLabels != null) and (i < value->queueLabelCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDebugUtilsLabelEXT*>(value->pQueueLabels + i)), header );
			}
			UnpackPointer( INOUT value->pCmdBufLabels, header );
			for (uint i = 0; (value->pCmdBufLabels != null) and (i < value->cmdBufLabelCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDebugUtilsLabelEXT*>(value->pCmdBufLabels + i)), header );
			}
			UnpackPointer( INOUT value->pObjects, header );
			for (uint i = 0; (value->pObjects != null) and (i < value->objectCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDebugUtilsObjectNameInfoEXT*>(value->pObjects + i)), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT : {
			VkDebugUtilsMessengerCreateInfoEXT*  value = BitCast<VkDebugUtilsMessengerCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pUserData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT : {
			VkWriteDescriptorSetInlineUniformBlockEXT*  value = BitCast<VkWriteDescriptorSetInlineUniformBlockEXT*>( ptr );
			UnpackPointer( INOUT value->pData, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV : {
			VkPipelineViewportShadingRateImageStateCreateInfoNV*  value = BitCast<VkPipelineViewportShadingRateImageStateCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pShadingRatePalettes, header );
			Unpack_VkShadingRatePaletteNV( const_cast<VkShadingRatePaletteNV*>(value->pShadingRatePalettes), header );
			break;
		}

		case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT : {
			VkSampleLocationsInfoEXT*  value = BitCast<VkSampleLocationsInfoEXT*>( ptr );
			Unpack_VkExtent2D( &value->sampleLocationGridSize, header );
			UnpackPointer( INOUT value->pSampleLocations, header );
			for (uint i = 0; (value->pSampleLocations != null) and (i < value->sampleLocationsCount); ++i) {
				Unpack_VkSampleLocationEXT( const_cast<VkSampleLocationEXT*>(value->pSampleLocations + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT : {
			VkPipelineSampleLocationsStateCreateInfoEXT*  value = BitCast<VkPipelineSampleLocationsStateCreateInfoEXT*>( ptr );
			UnpackStruct( BitCast<VkBaseOutStructure*>(&value->sampleLocationsInfo), header );
			break;
		}

		case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT : {
			VkPhysicalDeviceSampleLocationsPropertiesEXT*  value = BitCast<VkPhysicalDeviceSampleLocationsPropertiesEXT*>( ptr );
			Unpack_VkExtent2D( &value->maxSampleLocationGridSize, header );
			break;
		}

		case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT : {
			VkMultisamplePropertiesEXT*  value = BitCast<VkMultisamplePropertiesEXT*>( ptr );
			Unpack_VkExtent2D( &value->maxSampleLocationGridSize, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV : {
			VkPipelineCoverageModulationStateCreateInfoNV*  value = BitCast<VkPipelineCoverageModulationStateCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pCoverageModulationTable, header );
			break;
		}

		case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT : {
			VkDrmFormatModifierPropertiesListEXT*  value = BitCast<VkDrmFormatModifierPropertiesListEXT*>( ptr );
			UnpackPointer( INOUT value->pDrmFormatModifierProperties, header );
			for (uint i = 0; (value->pDrmFormatModifierProperties != null) and (i < value->drmFormatModifierCount); ++i) {
				Unpack_VkDrmFormatModifierPropertiesEXT( const_cast<VkDrmFormatModifierPropertiesEXT*>(value->pDrmFormatModifierProperties + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT : {
			VkPhysicalDeviceImageDrmFormatModifierInfoEXT*  value = BitCast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pQueueFamilyIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT : {
			VkImageDrmFormatModifierListCreateInfoEXT*  value = BitCast<VkImageDrmFormatModifierListCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pDrmFormatModifiers, header );
			break;
		}

		case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID : {
			#ifdef VULKAN_ANDROID_H_
			VkAndroidHardwareBufferFormatPropertiesANDROID*  value = BitCast<VkAndroidHardwareBufferFormatPropertiesANDROID*>( ptr );
			Unpack_VkComponentMapping( &value->samplerYcbcrConversionComponents, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV : {
			VkRayTracingPipelineCreateInfoNV*  value = BitCast<VkRayTracingPipelineCreateInfoNV*>( ptr );
			UnpackPointer( INOUT value->pStages, header );
			for (uint i = 0; (value->pStages != null) and (i < value->stageCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineShaderStageCreateInfo*>(value->pStages + i)), header );
			}
			UnpackPointer( INOUT value->pGroups, header );
			for (uint i = 0; (value->pGroups != null) and (i < value->groupCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkRayTracingShaderGroupCreateInfoNV*>(value->pGroups + i)), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_GEOMETRY_NV : {
			VkGeometryNV*  value = BitCast<VkGeometryNV*>( ptr );
			Unpack_VkGeometryDataNV( &value->geometry, header );
			break;
		}

		case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV : {
			VkAccelerationStructureCreateInfoNV*  value = BitCast<VkAccelerationStructureCreateInfoNV*>( ptr );
			UnpackStruct( BitCast<VkBaseOutStructure*>(&value->info), header );
			break;
		}

		case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV : {
			VkBindAccelerationStructureMemoryInfoNV*  value = BitCast<VkBindAccelerationStructureMemoryInfoNV*>( ptr );
			UnpackPointer( INOUT value->pDeviceIndices, header );
			break;
		}

		case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV : {
			VkWriteDescriptorSetAccelerationStructureNV*  value = BitCast<VkWriteDescriptorSetAccelerationStructureNV*>( ptr );
			UnpackPointer( INOUT value->pAccelerationStructures, header );
			break;
		}

		case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT : {
			VkPipelineVertexInputDivisorStateCreateInfoEXT*  value = BitCast<VkPipelineVertexInputDivisorStateCreateInfoEXT*>( ptr );
			UnpackPointer( INOUT value->pVertexBindingDivisors, header );
			for (uint i = 0; (value->pVertexBindingDivisors != null) and (i < value->vertexBindingDivisorCount); ++i) {
				Unpack_VkVertexInputBindingDivisorDescriptionEXT( const_cast<VkVertexInputBindingDivisorDescriptionEXT*>(value->pVertexBindingDivisors + i), header );
			}
			break;
		}

		case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV : {
			VkCheckpointDataNV*  value = BitCast<VkCheckpointDataNV*>( ptr );
			UnpackPointer( INOUT value->pCheckpointMarker, header );
			break;
		}

		case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkWin32KeyedMutexAcquireReleaseInfoKHR*  value = BitCast<VkWin32KeyedMutexAcquireReleaseInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pAcquireSyncs, header );
			UnpackPointer( INOUT value->pAcquireKeys, header );
			UnpackPointer( INOUT value->pAcquireTimeouts, header );
			UnpackPointer( INOUT value->pReleaseSyncs, header );
			UnpackPointer( INOUT value->pReleaseKeys, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR : {
			#ifdef VULKAN_WIN32_H_
			VkExportFenceWin32HandleInfoKHR*  value = BitCast<VkExportFenceWin32HandleInfoKHR*>( ptr );
			UnpackPointer( INOUT value->pAttributes, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID : {
			#ifdef VULKAN_ANDROID_H_
			VkImportAndroidHardwareBufferInfoANDROID*  value = BitCast<VkImportAndroidHardwareBufferInfoANDROID*>( ptr );
			UnpackPointer( INOUT value->buffer, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR : {
			#ifdef VULKAN_XLIB_H_
			VkXlibSurfaceCreateInfoKHR*  value = BitCast<VkXlibSurfaceCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->dpy, header );
			#endif
			break;
		}

		case VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR : {
			#ifdef VULKAN_WAYLAND_H_
			VkWaylandSurfaceCreateInfoKHR*  value = BitCast<VkWaylandSurfaceCreateInfoKHR*>( ptr );
			UnpackPointer( INOUT value->display, header );
			UnpackPointer( INOUT value->surface, header );
			#endif
			break;
		}

	case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN : break;
	case VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK : break;
	case VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK : break;
	case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA : break;
	case VK_STRUCTURE_TYPE_RANGE_SIZE : break;
	case VK_STRUCTURE_TYPE_MAX_ENUM : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_MEMORY_BARRIER : break;
	case VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR : break;
	case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID : break;
	case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV : break;
	case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 : break;
	case VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR : break;
	case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO : break;
	case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX : break;
	case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO : break;
	case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO : break;
	case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV : break;
	case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO : break;
	case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO : break;
	case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT : break;
	case VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX : break;
	case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER : break;
	case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO : break;
	case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO : break;
	case VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES : break;
	case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS : break;
	case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO : break;
	case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO : break;
	case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO : break;
	case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 : break;
	case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 : break;
	case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR : break;
	case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES : break;
	case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 : break;
	case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO : break;
	case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO : break;
	case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES : break;
	case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV : break;
	case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO : break;
	case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR : break;
	case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR : break;
	case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR : break;
	case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR : break;
	case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR : break;
	case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV : break;
	case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR : break;
	case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR : break;
	case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID : break;
	case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR : break;
	case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD : break;
	case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD : break;
	case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT : break;
	case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV : break;
	case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX : break;
	case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV : break;
	case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV : break;
	case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD : break;
	case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV : break;
	case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT : break;
	case VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR : break;
	case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID : break;
	case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID : break;
	}
	DISABLE_ENUM_CHECKS();
}
//-----------------------------------------------------------------------------

static void Unpack_VkPhysicalDeviceSparseProperties (VkPhysicalDeviceSparseProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDescriptorUpdateTemplateEntry (VkDescriptorUpdateTemplateEntry *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPhysicalDeviceLimits (VkPhysicalDeviceLimits *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageFormatProperties (VkImageFormatProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkExtent3D( &ptr->maxExtent, header );
}

static void Unpack_VkFormatProperties (VkFormatProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPipelineColorBlendAttachmentState (VkPipelineColorBlendAttachmentState *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkAllocationCallbacks (VkAllocationCallbacks *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pUserData, header );
}

static void Unpack_VkSubresourceLayout (VkSubresourceLayout *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPhysicalDeviceFeatures (VkPhysicalDeviceFeatures *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExtent3D (VkExtent3D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPhysicalDeviceProperties (VkPhysicalDeviceProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkPhysicalDeviceLimits( &ptr->limits, header );
	Unpack_VkPhysicalDeviceSparseProperties( &ptr->sparseProperties, header );
}

static void Unpack_VkSparseBufferMemoryBindInfo (VkSparseBufferMemoryBindInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pBinds, header );
	for (uint i = 0; (ptr->pBinds != null) and (i < ptr->bindCount); ++i) {
		Unpack_VkSparseMemoryBind( const_cast<VkSparseMemoryBind*>(ptr->pBinds + i), header );
	}
}

static void Unpack_VkQueueFamilyProperties (VkQueueFamilyProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkExtent3D( &ptr->minImageTransferGranularity, header );
}

static void Unpack_VkMemoryType (VkMemoryType *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkMemoryHeap (VkMemoryHeap *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPhysicalDeviceMemoryProperties (VkPhysicalDeviceMemoryProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkOffset2D (VkOffset2D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSparseMemoryBind (VkSparseMemoryBind *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExtensionProperties (VkExtensionProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkLayerProperties (VkLayerProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSpecializationMapEntry (VkSpecializationMapEntry *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkComponentMapping (VkComponentMapping *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkMemoryRequirements (VkMemoryRequirements *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageResolve (VkImageResolve *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkImageSubresourceLayers( &ptr->srcSubresource, header );
	Unpack_VkOffset3D( &ptr->srcOffset, header );
	Unpack_VkImageSubresourceLayers( &ptr->dstSubresource, header );
	Unpack_VkOffset3D( &ptr->dstOffset, header );
	Unpack_VkExtent3D( &ptr->extent, header );
}

static void Unpack_VkSparseImageFormatProperties (VkSparseImageFormatProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkExtent3D( &ptr->imageGranularity, header );
}

static void Unpack_VkSparseImageMemoryRequirements (VkSparseImageMemoryRequirements *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkSparseImageFormatProperties( &ptr->formatProperties, header );
}

static void Unpack_VkSparseImageOpaqueMemoryBindInfo (VkSparseImageOpaqueMemoryBindInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pBinds, header );
	for (uint i = 0; (ptr->pBinds != null) and (i < ptr->bindCount); ++i) {
		Unpack_VkSparseMemoryBind( const_cast<VkSparseMemoryBind*>(ptr->pBinds + i), header );
	}
}

static void Unpack_VkImageSubresource (VkImageSubresource *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkOffset3D (VkOffset3D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSparseImageMemoryBind (VkSparseImageMemoryBind *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkImageSubresource( &ptr->subresource, header );
	Unpack_VkOffset3D( &ptr->offset, header );
	Unpack_VkExtent3D( &ptr->extent, header );
}

static void Unpack_VkSparseImageMemoryBindInfo (VkSparseImageMemoryBindInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pBinds, header );
	for (uint i = 0; (ptr->pBinds != null) and (i < ptr->bindCount); ++i) {
		Unpack_VkSparseImageMemoryBind( const_cast<VkSparseImageMemoryBind*>(ptr->pBinds + i), header );
	}
}

static void Unpack_VkViewport (VkViewport *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageSubresourceRange (VkImageSubresourceRange *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSpecializationInfo (VkSpecializationInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pMapEntries, header );
	for (uint i = 0; (ptr->pMapEntries != null) and (i < ptr->mapEntryCount); ++i) {
		Unpack_VkSpecializationMapEntry( const_cast<VkSpecializationMapEntry*>(ptr->pMapEntries + i), header );
	}
	UnpackPointer( INOUT ptr->pData, header );
}

static void Unpack_VkVertexInputBindingDescription (VkVertexInputBindingDescription *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageCopy (VkImageCopy *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkImageSubresourceLayers( &ptr->srcSubresource, header );
	Unpack_VkOffset3D( &ptr->srcOffset, header );
	Unpack_VkImageSubresourceLayers( &ptr->dstSubresource, header );
	Unpack_VkOffset3D( &ptr->dstOffset, header );
	Unpack_VkExtent3D( &ptr->extent, header );
}

static void Unpack_VkVertexInputAttributeDescription (VkVertexInputAttributeDescription *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExtent2D (VkExtent2D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkRect2D (VkRect2D *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkOffset2D( &ptr->offset, header );
	Unpack_VkExtent2D( &ptr->extent, header );
}

static void Unpack_VkStencilOpState (VkStencilOpState *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkXYColorEXT (VkXYColorEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPushConstantRange (VkPushConstantRange *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDisplayPlanePropertiesKHR (VkDisplayPlanePropertiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDescriptorSetLayoutBinding (VkDescriptorSetLayoutBinding *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pImmutableSamplers, header );
}

static void Unpack_VkDescriptorPoolSize (VkDescriptorPoolSize *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkClearValue (VkClearValue *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkClearColorValue( &ptr->color, header );
	Unpack_VkClearDepthStencilValue( &ptr->depthStencil, header );
}

static void Unpack_VkDescriptorImageInfo (VkDescriptorImageInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDescriptorBufferInfo (VkDescriptorBufferInfo *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkAttachmentDescription (VkAttachmentDescription *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkAttachmentReference (VkAttachmentReference *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSubpassDescription (VkSubpassDescription *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pInputAttachments, header );
	for (uint i = 0; (ptr->pInputAttachments != null) and (i < ptr->inputAttachmentCount); ++i) {
		Unpack_VkAttachmentReference( const_cast<VkAttachmentReference*>(ptr->pInputAttachments + i), header );
	}
	UnpackPointer( INOUT ptr->pColorAttachments, header );
	for (uint i = 0; (ptr->pColorAttachments != null) and (i < ptr->colorAttachmentCount); ++i) {
		Unpack_VkAttachmentReference( const_cast<VkAttachmentReference*>(ptr->pColorAttachments + i), header );
	}
	UnpackPointer( INOUT ptr->pResolveAttachments, header );
	for (uint i = 0; (ptr->pResolveAttachments != null) and (i < ptr->colorAttachmentCount); ++i) {
		Unpack_VkAttachmentReference( const_cast<VkAttachmentReference*>(ptr->pResolveAttachments + i), header );
	}
	UnpackPointer( INOUT ptr->pDepthStencilAttachment, header );
	Unpack_VkAttachmentReference( const_cast<VkAttachmentReference*>(ptr->pDepthStencilAttachment), header );
	UnpackPointer( INOUT ptr->pPreserveAttachments, header );
}

static void Unpack_VkSubpassDependency (VkSubpassDependency *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkBufferCopy (VkBufferCopy *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDisplayModePropertiesKHR (VkDisplayModePropertiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkDisplayModeParametersKHR( &ptr->parameters, header );
}

static void Unpack_VkImageSubresourceLayers (VkImageSubresourceLayers *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkImageBlit (VkImageBlit *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkImageSubresourceLayers( &ptr->srcSubresource, header );
	Unpack_VkImageSubresourceLayers( &ptr->dstSubresource, header );
}

static void Unpack_VkBufferImageCopy (VkBufferImageCopy *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkImageSubresourceLayers( &ptr->imageSubresource, header );
	Unpack_VkOffset3D( &ptr->imageOffset, header );
	Unpack_VkExtent3D( &ptr->imageExtent, header );
}

static void Unpack_VkClearColorValue (VkClearColorValue *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkClearDepthStencilValue (VkClearDepthStencilValue *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkClearAttachment (VkClearAttachment *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkClearValue( &ptr->clearValue, header );
}

static void Unpack_VkClearRect (VkClearRect *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkRect2D( &ptr->rect, header );
}

static void Unpack_VkViewportSwizzleNV (VkViewportSwizzleNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkShadingRatePaletteNV (VkShadingRatePaletteNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pShadingRatePaletteEntries, header );
}

static void Unpack_VkInputAttachmentAspectReference (VkInputAttachmentAspectReference *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExternalMemoryProperties (VkExternalMemoryProperties *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkCoarseSampleLocationNV (VkCoarseSampleLocationNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDisplayModeParametersKHR (VkDisplayModeParametersKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkExtent2D( &ptr->visibleRegion, header );
}

static void Unpack_VkSurfaceCapabilitiesKHR (VkSurfaceCapabilitiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkExtent2D( &ptr->currentExtent, header );
	Unpack_VkExtent2D( &ptr->minImageExtent, header );
	Unpack_VkExtent2D( &ptr->maxImageExtent, header );
}

static void Unpack_VkSurfaceFormatKHR (VkSurfaceFormatKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkExternalImageFormatPropertiesNV (VkExternalImageFormatPropertiesNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkImageFormatProperties( &ptr->imageFormatProperties, header );
}

static void Unpack_VkIndirectCommandsLayoutTokenNVX (VkIndirectCommandsLayoutTokenNVX *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkVertexInputBindingDivisorDescriptionEXT (VkVertexInputBindingDivisorDescriptionEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDisplayPropertiesKHR (VkDisplayPropertiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->displayName, header );
	Unpack_VkExtent2D( &ptr->physicalDimensions, header );
	Unpack_VkExtent2D( &ptr->physicalResolution, header );
}

static void Unpack_VkDisplayPlaneCapabilitiesKHR (VkDisplayPlaneCapabilitiesKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkOffset2D( &ptr->minSrcPosition, header );
	Unpack_VkOffset2D( &ptr->maxSrcPosition, header );
	Unpack_VkExtent2D( &ptr->minSrcExtent, header );
	Unpack_VkExtent2D( &ptr->maxSrcExtent, header );
	Unpack_VkOffset2D( &ptr->minDstPosition, header );
	Unpack_VkOffset2D( &ptr->maxDstPosition, header );
	Unpack_VkExtent2D( &ptr->minDstExtent, header );
	Unpack_VkExtent2D( &ptr->maxDstExtent, header );
}

static void Unpack_VkSubpassSampleLocationsEXT (VkSubpassSampleLocationsEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackStruct( BitCast<VkBaseOutStructure*>(&ptr->sampleLocationsInfo), header );
}

static void Unpack_VkRectLayerKHR (VkRectLayerKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	Unpack_VkOffset2D( &ptr->offset, header );
	Unpack_VkExtent2D( &ptr->extent, header );
}

static void Unpack_VkPresentRegionKHR (VkPresentRegionKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pRectangles, header );
	for (uint i = 0; (ptr->pRectangles != null) and (i < ptr->rectangleCount); ++i) {
		Unpack_VkRectLayerKHR( const_cast<VkRectLayerKHR*>(ptr->pRectangles + i), header );
	}
}

static void Unpack_VkConformanceVersionKHR (VkConformanceVersionKHR *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkCoarseSampleOrderCustomNV (VkCoarseSampleOrderCustomNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackPointer( INOUT ptr->pSampleLocations, header );
	for (uint i = 0; (ptr->pSampleLocations != null) and (i < ptr->sampleLocationCount); ++i) {
		Unpack_VkCoarseSampleLocationNV( const_cast<VkCoarseSampleLocationNV*>(ptr->pSampleLocations + i), header );
	}
}

static void Unpack_VkIndirectCommandsTokenNVX (VkIndirectCommandsTokenNVX *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkObjectTableEntryNVX (VkObjectTableEntryNVX *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkViewportWScalingNV (VkViewportWScalingNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkRefreshCycleDurationGOOGLE (VkRefreshCycleDurationGOOGLE *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPastPresentationTimingGOOGLE (VkPastPresentationTimingGOOGLE *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkDrmFormatModifierPropertiesEXT (VkDrmFormatModifierPropertiesEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkPresentTimeGOOGLE (VkPresentTimeGOOGLE *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkSampleLocationEXT (VkSampleLocationEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
}

static void Unpack_VkAttachmentSampleLocationsEXT (VkAttachmentSampleLocationsEXT *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackStruct( BitCast<VkBaseOutStructure*>(&ptr->sampleLocationsInfo), header );
}

static void Unpack_VkGeometryDataNV (VkGeometryDataNV *ptr, vktrace_trace_packet_header *header)
{
	if ( ptr == null ) return;
	UnpackStruct( BitCast<VkBaseOutStructure*>(&ptr->triangles), header );
	UnpackStruct( BitCast<VkBaseOutStructure*>(&ptr->aabbs), header );
}

//-----------------------------------------------------------------------------

static void UnpackPacket (vktrace_trace_packet_header *header)
{
	if ( not header ) return;
	ENABLE_ENUM_CHECKS();
	switch ( header->packet_id )
	{
		case VKTRACE_TPI_MESSAGE : break;
		case VKTRACE_TPI_MARKER_CHECKPOINT : break;
		case VKTRACE_TPI_MARKER_API_BOUNDARY : break;
		case VKTRACE_TPI_MARKER_API_GROUP_BEGIN : break;
		case VKTRACE_TPI_MARKER_API_GROUP_END : break;
		case VKTRACE_TPI_MARKER_TERMINATE_PROCESS : break;
		case VKTRACE_TPI_PORTABILITY_TABLE : break;
		case VKTRACE_TPI_VK_vkApiVersion : {
			packet_vkApiVersion* packet = BitCast<packet_vkApiVersion*>(header->pBody);
			packet->header = header;
			break;
		}
		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalImageFormatPropertiesNV : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceExternalImageFormatPropertiesNV*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalImageFormatProperties, header );
			Unpack_VkExternalImageFormatPropertiesNV( const_cast<VkExternalImageFormatPropertiesNV*>(packet->pExternalImageFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndirectCountAMD : {
			auto*  packet = BitCast<packet_vkCmdDrawIndirectCountAMD*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndexedIndirectCountAMD : {
			auto*  packet = BitCast<packet_vkCmdDrawIndexedIndirectCountAMD*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDebugReportCallbackEXT : {
			auto*  packet = BitCast<packet_vkCreateDebugReportCallbackEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDebugReportCallbackCreateInfoEXT*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pCallback, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDebugReportCallbackEXT : {
			auto*  packet = BitCast<packet_vkDestroyDebugReportCallbackEXT*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkDebugReportMessageEXT : {
			auto*  packet = BitCast<packet_vkDebugReportMessageEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pLayerPrefix, header );
			UnpackPointer( INOUT packet->pMessage, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDebugMarkerSetObjectTagEXT : {
			auto*  packet = BitCast<packet_vkDebugMarkerSetObjectTagEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pTagInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDebugMarkerObjectTagInfoEXT*>(packet->pTagInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkDebugMarkerSetObjectNameEXT : {
			auto*  packet = BitCast<packet_vkDebugMarkerSetObjectNameEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pNameInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDebugMarkerObjectNameInfoEXT*>(packet->pNameInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDebugMarkerBeginEXT : {
			auto*  packet = BitCast<packet_vkCmdDebugMarkerBeginEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMarkerInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDebugMarkerMarkerInfoEXT*>(packet->pMarkerInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDebugMarkerEndEXT : {
			auto*  packet = BitCast<packet_vkCmdDebugMarkerEndEXT*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDebugMarkerInsertEXT : {
			auto*  packet = BitCast<packet_vkCmdDebugMarkerInsertEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMarkerInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDebugMarkerMarkerInfoEXT*>(packet->pMarkerInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateInstance : {
			auto*  packet = BitCast<packet_vkCreateInstance*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkInstanceCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pInstance, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyInstance : {
			auto*  packet = BitCast<packet_vkDestroyInstance*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkEnumeratePhysicalDevices : {
			auto*  packet = BitCast<packet_vkEnumeratePhysicalDevices*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPhysicalDeviceCount, header );
			UnpackPointer( INOUT packet->pPhysicalDevices, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFeatures : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceFeatures*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFeatures, header );
			Unpack_VkPhysicalDeviceFeatures( const_cast<VkPhysicalDeviceFeatures*>(packet->pFeatures), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFormatProperties : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceFormatProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatProperties, header );
			Unpack_VkFormatProperties( const_cast<VkFormatProperties*>(packet->pFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceImageFormatProperties : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceImageFormatProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImageFormatProperties, header );
			Unpack_VkImageFormatProperties( const_cast<VkImageFormatProperties*>(packet->pImageFormatProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceProperties : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkPhysicalDeviceProperties( const_cast<VkPhysicalDeviceProperties*>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceQueueFamilyProperties : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceQueueFamilyProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueueFamilyPropertyCount, header );
			UnpackPointer( INOUT packet->pQueueFamilyProperties, header );
			Unpack_VkQueueFamilyProperties( const_cast<VkQueueFamilyProperties*>(packet->pQueueFamilyProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceMemoryProperties : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceMemoryProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryProperties, header );
			Unpack_VkPhysicalDeviceMemoryProperties( const_cast<VkPhysicalDeviceMemoryProperties*>(packet->pMemoryProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetInstanceProcAddr : {
			auto*  packet = BitCast<packet_vkGetInstanceProcAddr*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pName, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceProcAddr : {
			auto*  packet = BitCast<packet_vkGetDeviceProcAddr*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pName, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDevice : {
			auto*  packet = BitCast<packet_vkCreateDevice*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDeviceCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pDevice, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDevice : {
			auto*  packet = BitCast<packet_vkDestroyDevice*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateInstanceExtensionProperties : {
			auto*  packet = BitCast<packet_vkEnumerateInstanceExtensionProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pLayerName, header );
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkExtensionProperties( const_cast<VkExtensionProperties*>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateDeviceExtensionProperties : {
			auto*  packet = BitCast<packet_vkEnumerateDeviceExtensionProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pLayerName, header );
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkExtensionProperties( const_cast<VkExtensionProperties*>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateInstanceLayerProperties : {
			auto*  packet = BitCast<packet_vkEnumerateInstanceLayerProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkLayerProperties( const_cast<VkLayerProperties*>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateDeviceLayerProperties : {
			auto*  packet = BitCast<packet_vkEnumerateDeviceLayerProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkLayerProperties( const_cast<VkLayerProperties*>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceQueue : {
			auto*  packet = BitCast<packet_vkGetDeviceQueue*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueue, header );
			break;
		}

		case VKTRACE_TPI_VK_vkQueueSubmit : {
			auto*  packet = BitCast<packet_vkQueueSubmit*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSubmits, header );
			for (uint i = 0; (packet->pSubmits != null) and (i < packet->submitCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSubmitInfo*>(packet->pSubmits + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkQueueWaitIdle : {
			auto*  packet = BitCast<packet_vkQueueWaitIdle*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkDeviceWaitIdle : {
			auto*  packet = BitCast<packet_vkDeviceWaitIdle*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkAllocateMemory : {
			auto*  packet = BitCast<packet_vkAllocateMemory*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAllocateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryAllocateInfo*>(packet->pAllocateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pMemory, header );
			break;
		}

		case VKTRACE_TPI_VK_vkFreeMemory : {
			auto*  packet = BitCast<packet_vkFreeMemory*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkMapMemory : {
			auto*  packet = BitCast<packet_vkMapMemory*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->ppData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkUnmapMemory : {
			auto*  packet = BitCast<packet_vkUnmapMemory*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkFlushMappedMemoryRanges : {
			auto*  packet = BitCast<packet_vkFlushMappedMemoryRanges*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryRanges, header );
			UnpackPointer( INOUT packet->ppData, header );
			for (uint i = 0; (packet->ppData != null) and (i < packet->memoryRangeCount); ++i) {
				UnpackPointer( INOUT packet->ppData[i], header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkInvalidateMappedMemoryRanges : {
			auto*  packet = BitCast<packet_vkInvalidateMappedMemoryRanges*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryRanges, header );
			UnpackPointer( INOUT packet->ppData, header );
			for (uint i = 0; (packet->ppData != null) and (i < packet->memoryRangeCount); ++i) {
				UnpackPointer( INOUT packet->ppData[i], header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceMemoryCommitment : {
			auto*  packet = BitCast<packet_vkGetDeviceMemoryCommitment*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCommittedMemoryInBytes, header );
			break;
		}

		case VKTRACE_TPI_VK_vkBindBufferMemory : {
			auto*  packet = BitCast<packet_vkBindBufferMemory*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkBindImageMemory : {
			auto*  packet = BitCast<packet_vkBindImageMemory*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkGetBufferMemoryRequirements : {
			auto*  packet = BitCast<packet_vkGetBufferMemoryRequirements*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			Unpack_VkMemoryRequirements( const_cast<VkMemoryRequirements*>(packet->pMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageMemoryRequirements : {
			auto*  packet = BitCast<packet_vkGetImageMemoryRequirements*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			Unpack_VkMemoryRequirements( const_cast<VkMemoryRequirements*>(packet->pMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageSparseMemoryRequirements : {
			auto*  packet = BitCast<packet_vkGetImageSparseMemoryRequirements*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSparseMemoryRequirementCount, header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirements, header );
			Unpack_VkSparseImageMemoryRequirements( const_cast<VkSparseImageMemoryRequirements*>(packet->pSparseMemoryRequirements), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSparseImageFormatProperties : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSparseImageFormatProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkSparseImageFormatProperties( const_cast<VkSparseImageFormatProperties*>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkQueueBindSparse : {
			auto*  packet = BitCast<packet_vkQueueBindSparse*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfo, header );
			for (uint i = 0; (packet->pBindInfo != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBindSparseInfo*>(packet->pBindInfo + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCreateFence : {
			auto*  packet = BitCast<packet_vkCreateFence*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkFenceCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pFence, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyFence : {
			auto*  packet = BitCast<packet_vkDestroyFence*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkResetFences : {
			auto*  packet = BitCast<packet_vkResetFences*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFences, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetFenceStatus : {
			auto*  packet = BitCast<packet_vkGetFenceStatus*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkWaitForFences : {
			auto*  packet = BitCast<packet_vkWaitForFences*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFences, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSemaphore : {
			auto*  packet = BitCast<packet_vkCreateSemaphore*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSemaphoreCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSemaphore, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySemaphore : {
			auto*  packet = BitCast<packet_vkDestroySemaphore*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateEvent : {
			auto*  packet = BitCast<packet_vkCreateEvent*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkEventCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pEvent, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyEvent : {
			auto*  packet = BitCast<packet_vkDestroyEvent*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetEventStatus : {
			auto*  packet = BitCast<packet_vkGetEventStatus*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkSetEvent : {
			auto*  packet = BitCast<packet_vkSetEvent*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkResetEvent : {
			auto*  packet = BitCast<packet_vkResetEvent*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateQueryPool : {
			auto*  packet = BitCast<packet_vkCreateQueryPool*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkQueryPoolCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pQueryPool, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyQueryPool : {
			auto*  packet = BitCast<packet_vkDestroyQueryPool*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetQueryPoolResults : {
			auto*  packet = BitCast<packet_vkGetQueryPoolResults*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateBuffer : {
			auto*  packet = BitCast<packet_vkCreateBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBufferCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pBuffer, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyBuffer : {
			auto*  packet = BitCast<packet_vkDestroyBuffer*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateBufferView : {
			auto*  packet = BitCast<packet_vkCreateBufferView*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBufferViewCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pView, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyBufferView : {
			auto*  packet = BitCast<packet_vkDestroyBufferView*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateImage : {
			auto*  packet = BitCast<packet_vkCreateImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pImage, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyImage : {
			auto*  packet = BitCast<packet_vkDestroyImage*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageSubresourceLayout : {
			auto*  packet = BitCast<packet_vkGetImageSubresourceLayout*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSubresource, header );
			Unpack_VkImageSubresource( const_cast<VkImageSubresource*>(packet->pSubresource), header );
			UnpackPointer( INOUT packet->pLayout, header );
			Unpack_VkSubresourceLayout( const_cast<VkSubresourceLayout*>(packet->pLayout), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateImageView : {
			auto*  packet = BitCast<packet_vkCreateImageView*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageViewCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pView, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyImageView : {
			auto*  packet = BitCast<packet_vkDestroyImageView*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateShaderModule : {
			auto*  packet = BitCast<packet_vkCreateShaderModule*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkShaderModuleCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pShaderModule, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyShaderModule : {
			auto*  packet = BitCast<packet_vkDestroyShaderModule*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreatePipelineCache : {
			auto*  packet = BitCast<packet_vkCreatePipelineCache*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineCacheCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pPipelineCache, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyPipelineCache : {
			auto*  packet = BitCast<packet_vkDestroyPipelineCache*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPipelineCacheData : {
			auto*  packet = BitCast<packet_vkGetPipelineCacheData*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDataSize, header );
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkMergePipelineCaches : {
			auto*  packet = BitCast<packet_vkMergePipelineCaches*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSrcCaches, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateGraphicsPipelines : {
			auto*  packet = BitCast<packet_vkCreateGraphicsPipelines*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfos, header );
			for (uint i = 0; (packet->pCreateInfos != null) and (i < packet->createInfoCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkGraphicsPipelineCreateInfo*>(packet->pCreateInfos + i)), header );
			}
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pPipelines, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateComputePipelines : {
			auto*  packet = BitCast<packet_vkCreateComputePipelines*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfos, header );
			for (uint i = 0; (packet->pCreateInfos != null) and (i < packet->createInfoCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkComputePipelineCreateInfo*>(packet->pCreateInfos + i)), header );
			}
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pPipelines, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyPipeline : {
			auto*  packet = BitCast<packet_vkDestroyPipeline*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreatePipelineLayout : {
			auto*  packet = BitCast<packet_vkCreatePipelineLayout*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPipelineLayoutCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pPipelineLayout, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyPipelineLayout : {
			auto*  packet = BitCast<packet_vkDestroyPipelineLayout*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSampler : {
			auto*  packet = BitCast<packet_vkCreateSampler*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSamplerCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSampler, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySampler : {
			auto*  packet = BitCast<packet_vkDestroySampler*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDescriptorSetLayout : {
			auto*  packet = BitCast<packet_vkCreateDescriptorSetLayout*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDescriptorSetLayoutCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSetLayout, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDescriptorSetLayout : {
			auto*  packet = BitCast<packet_vkDestroyDescriptorSetLayout*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDescriptorPool : {
			auto*  packet = BitCast<packet_vkCreateDescriptorPool*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDescriptorPoolCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pDescriptorPool, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDescriptorPool : {
			auto*  packet = BitCast<packet_vkDestroyDescriptorPool*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkResetDescriptorPool : {
			auto*  packet = BitCast<packet_vkResetDescriptorPool*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkAllocateDescriptorSets : {
			auto*  packet = BitCast<packet_vkAllocateDescriptorSets*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAllocateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDescriptorSetAllocateInfo*>(packet->pAllocateInfo)), header );
			UnpackPointer( INOUT packet->pDescriptorSets, header );
			break;
		}

		case VKTRACE_TPI_VK_vkFreeDescriptorSets : {
			auto*  packet = BitCast<packet_vkFreeDescriptorSets*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDescriptorSets, header );
			break;
		}

		case VKTRACE_TPI_VK_vkUpdateDescriptorSets : {
			auto*  packet = BitCast<packet_vkUpdateDescriptorSets*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDescriptorWrites, header );
			for (uint i = 0; (packet->pDescriptorWrites != null) and (i < packet->descriptorWriteCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkWriteDescriptorSet*>(packet->pDescriptorWrites + i)), header );
			}
			UnpackPointer( INOUT packet->pDescriptorCopies, header );
			for (uint i = 0; (packet->pDescriptorCopies != null) and (i < packet->descriptorCopyCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkCopyDescriptorSet*>(packet->pDescriptorCopies + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCreateFramebuffer : {
			auto*  packet = BitCast<packet_vkCreateFramebuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkFramebufferCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pFramebuffer, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyFramebuffer : {
			auto*  packet = BitCast<packet_vkDestroyFramebuffer*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateRenderPass : {
			auto*  packet = BitCast<packet_vkCreateRenderPass*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkRenderPassCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pRenderPass, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyRenderPass : {
			auto*  packet = BitCast<packet_vkDestroyRenderPass*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetRenderAreaGranularity : {
			auto*  packet = BitCast<packet_vkGetRenderAreaGranularity*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGranularity, header );
			Unpack_VkExtent2D( const_cast<VkExtent2D*>(packet->pGranularity), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateCommandPool : {
			auto*  packet = BitCast<packet_vkCreateCommandPool*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkCommandPoolCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pCommandPool, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyCommandPool : {
			auto*  packet = BitCast<packet_vkDestroyCommandPool*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkResetCommandPool : {
			auto*  packet = BitCast<packet_vkResetCommandPool*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkAllocateCommandBuffers : {
			auto*  packet = BitCast<packet_vkAllocateCommandBuffers*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAllocateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkCommandBufferAllocateInfo*>(packet->pAllocateInfo)), header );
			UnpackPointer( INOUT packet->pCommandBuffers, header );
			break;
		}

		case VKTRACE_TPI_VK_vkFreeCommandBuffers : {
			auto*  packet = BitCast<packet_vkFreeCommandBuffers*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCommandBuffers, header );
			break;
		}

		case VKTRACE_TPI_VK_vkBeginCommandBuffer : {
			auto*  packet = BitCast<packet_vkBeginCommandBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBeginInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkCommandBufferBeginInfo*>(packet->pBeginInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkEndCommandBuffer : {
			auto*  packet = BitCast<packet_vkEndCommandBuffer*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkResetCommandBuffer : {
			auto*  packet = BitCast<packet_vkResetCommandBuffer*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBindPipeline : {
			auto*  packet = BitCast<packet_vkCmdBindPipeline*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetViewport : {
			auto*  packet = BitCast<packet_vkCmdSetViewport*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pViewports, header );
			for (uint i = 0; (packet->pViewports != null) and (i < packet->viewportCount); ++i) {
				Unpack_VkViewport( const_cast<VkViewport*>(packet->pViewports + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetScissor : {
			auto*  packet = BitCast<packet_vkCmdSetScissor*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pScissors, header );
			for (uint i = 0; (packet->pScissors != null) and (i < packet->scissorCount); ++i) {
				Unpack_VkRect2D( const_cast<VkRect2D*>(packet->pScissors + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetLineWidth : {
			auto*  packet = BitCast<packet_vkCmdSetLineWidth*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDepthBias : {
			auto*  packet = BitCast<packet_vkCmdSetDepthBias*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetBlendConstants : {
			auto*  packet = BitCast<packet_vkCmdSetBlendConstants*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDepthBounds : {
			auto*  packet = BitCast<packet_vkCmdSetDepthBounds*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetStencilCompareMask : {
			auto*  packet = BitCast<packet_vkCmdSetStencilCompareMask*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetStencilWriteMask : {
			auto*  packet = BitCast<packet_vkCmdSetStencilWriteMask*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetStencilReference : {
			auto*  packet = BitCast<packet_vkCmdSetStencilReference*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBindDescriptorSets : {
			auto*  packet = BitCast<packet_vkCmdBindDescriptorSets*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDescriptorSets, header );
			UnpackPointer( INOUT packet->pDynamicOffsets, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBindIndexBuffer : {
			auto*  packet = BitCast<packet_vkCmdBindIndexBuffer*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBindVertexBuffers : {
			auto*  packet = BitCast<packet_vkCmdBindVertexBuffers*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBuffers, header );
			UnpackPointer( INOUT packet->pOffsets, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDraw : {
			auto*  packet = BitCast<packet_vkCmdDraw*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndexed : {
			auto*  packet = BitCast<packet_vkCmdDrawIndexed*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndirect : {
			auto*  packet = BitCast<packet_vkCmdDrawIndirect*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDrawIndexedIndirect : {
			auto*  packet = BitCast<packet_vkCmdDrawIndexedIndirect*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDispatch : {
			auto*  packet = BitCast<packet_vkCmdDispatch*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDispatchIndirect : {
			auto*  packet = BitCast<packet_vkCmdDispatchIndirect*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyBuffer : {
			auto*  packet = BitCast<packet_vkCmdCopyBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkBufferCopy( const_cast<VkBufferCopy*>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyImage : {
			auto*  packet = BitCast<packet_vkCmdCopyImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkImageCopy( const_cast<VkImageCopy*>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBlitImage : {
			auto*  packet = BitCast<packet_vkCmdBlitImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkImageBlit( const_cast<VkImageBlit*>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyBufferToImage : {
			auto*  packet = BitCast<packet_vkCmdCopyBufferToImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkBufferImageCopy( const_cast<VkBufferImageCopy*>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyImageToBuffer : {
			auto*  packet = BitCast<packet_vkCmdCopyImageToBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkBufferImageCopy( const_cast<VkBufferImageCopy*>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdUpdateBuffer : {
			auto*  packet = BitCast<packet_vkCmdUpdateBuffer*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdFillBuffer : {
			auto*  packet = BitCast<packet_vkCmdFillBuffer*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdClearColorImage : {
			auto*  packet = BitCast<packet_vkCmdClearColorImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pColor, header );
			Unpack_VkClearColorValue( const_cast<VkClearColorValue*>(packet->pColor), header );
			UnpackPointer( INOUT packet->pRanges, header );
			for (uint i = 0; (packet->pRanges != null) and (i < packet->rangeCount); ++i) {
				Unpack_VkImageSubresourceRange( const_cast<VkImageSubresourceRange*>(packet->pRanges + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdClearDepthStencilImage : {
			auto*  packet = BitCast<packet_vkCmdClearDepthStencilImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDepthStencil, header );
			Unpack_VkClearDepthStencilValue( const_cast<VkClearDepthStencilValue*>(packet->pDepthStencil), header );
			UnpackPointer( INOUT packet->pRanges, header );
			for (uint i = 0; (packet->pRanges != null) and (i < packet->rangeCount); ++i) {
				Unpack_VkImageSubresourceRange( const_cast<VkImageSubresourceRange*>(packet->pRanges + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdClearAttachments : {
			auto*  packet = BitCast<packet_vkCmdClearAttachments*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAttachments, header );
			for (uint i = 0; (packet->pAttachments != null) and (i < packet->attachmentCount); ++i) {
				Unpack_VkClearAttachment( const_cast<VkClearAttachment*>(packet->pAttachments + i), header );
			}
			UnpackPointer( INOUT packet->pRects, header );
			for (uint i = 0; (packet->pRects != null) and (i < packet->rectCount); ++i) {
				Unpack_VkClearRect( const_cast<VkClearRect*>(packet->pRects + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdResolveImage : {
			auto*  packet = BitCast<packet_vkCmdResolveImage*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRegions, header );
			for (uint i = 0; (packet->pRegions != null) and (i < packet->regionCount); ++i) {
				Unpack_VkImageResolve( const_cast<VkImageResolve*>(packet->pRegions + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetEvent : {
			auto*  packet = BitCast<packet_vkCmdSetEvent*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdResetEvent : {
			auto*  packet = BitCast<packet_vkCmdResetEvent*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdWaitEvents : {
			auto*  packet = BitCast<packet_vkCmdWaitEvents*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pEvents, header );
			UnpackPointer( INOUT packet->pMemoryBarriers, header );
			for (uint i = 0; (packet->pMemoryBarriers != null) and (i < packet->memoryBarrierCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryBarrier*>(packet->pMemoryBarriers + i)), header );
			}
			UnpackPointer( INOUT packet->pBufferMemoryBarriers, header );
			for (uint i = 0; (packet->pBufferMemoryBarriers != null) and (i < packet->bufferMemoryBarrierCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBufferMemoryBarrier*>(packet->pBufferMemoryBarriers + i)), header );
			}
			UnpackPointer( INOUT packet->pImageMemoryBarriers, header );
			for (uint i = 0; (packet->pImageMemoryBarriers != null) and (i < packet->imageMemoryBarrierCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageMemoryBarrier*>(packet->pImageMemoryBarriers + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdPipelineBarrier : {
			auto*  packet = BitCast<packet_vkCmdPipelineBarrier*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryBarriers, header );
			for (uint i = 0; (packet->pMemoryBarriers != null) and (i < packet->memoryBarrierCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryBarrier*>(packet->pMemoryBarriers + i)), header );
			}
			UnpackPointer( INOUT packet->pBufferMemoryBarriers, header );
			for (uint i = 0; (packet->pBufferMemoryBarriers != null) and (i < packet->bufferMemoryBarrierCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBufferMemoryBarrier*>(packet->pBufferMemoryBarriers + i)), header );
			}
			UnpackPointer( INOUT packet->pImageMemoryBarriers, header );
			for (uint i = 0; (packet->pImageMemoryBarriers != null) and (i < packet->imageMemoryBarrierCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageMemoryBarrier*>(packet->pImageMemoryBarriers + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBeginQuery : {
			auto*  packet = BitCast<packet_vkCmdBeginQuery*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdEndQuery : {
			auto*  packet = BitCast<packet_vkCmdEndQuery*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdResetQueryPool : {
			auto*  packet = BitCast<packet_vkCmdResetQueryPool*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdWriteTimestamp : {
			auto*  packet = BitCast<packet_vkCmdWriteTimestamp*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdCopyQueryPoolResults : {
			auto*  packet = BitCast<packet_vkCmdCopyQueryPoolResults*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdPushConstants : {
			auto*  packet = BitCast<packet_vkCmdPushConstants*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pValues, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdBeginRenderPass : {
			auto*  packet = BitCast<packet_vkCmdBeginRenderPass*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRenderPassBegin, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkRenderPassBeginInfo*>(packet->pRenderPassBegin)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdNextSubpass : {
			auto*  packet = BitCast<packet_vkCmdNextSubpass*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdEndRenderPass : {
			auto*  packet = BitCast<packet_vkCmdEndRenderPass*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdExecuteCommands : {
			auto*  packet = BitCast<packet_vkCmdExecuteCommands*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCommandBuffers, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySurfaceKHR : {
			auto*  packet = BitCast<packet_vkDestroySurfaceKHR*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceSupportKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceSupportKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSupported, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceCapabilitiesKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceCapabilitiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceCapabilities, header );
			Unpack_VkSurfaceCapabilitiesKHR( const_cast<VkSurfaceCapabilitiesKHR*>(packet->pSurfaceCapabilities), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceFormatsKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceFormatsKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceFormatCount, header );
			UnpackPointer( INOUT packet->pSurfaceFormats, header );
			Unpack_VkSurfaceFormatKHR( const_cast<VkSurfaceFormatKHR*>(packet->pSurfaceFormats), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfacePresentModesKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSurfacePresentModesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPresentModeCount, header );
			UnpackPointer( INOUT packet->pPresentModes, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSwapchainKHR : {
			auto*  packet = BitCast<packet_vkCreateSwapchainKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSwapchainCreateInfoKHR*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSwapchain, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySwapchainKHR : {
			auto*  packet = BitCast<packet_vkDestroySwapchainKHR*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetSwapchainImagesKHR : {
			auto*  packet = BitCast<packet_vkGetSwapchainImagesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSwapchainImageCount, header );
			UnpackPointer( INOUT packet->pSwapchainImages, header );
			break;
		}

		case VKTRACE_TPI_VK_vkAcquireNextImageKHR : {
			auto*  packet = BitCast<packet_vkAcquireNextImageKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImageIndex, header );
			break;
		}

		case VKTRACE_TPI_VK_vkQueuePresentKHR : {
			auto*  packet = BitCast<packet_vkQueuePresentKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPresentInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPresentInfoKHR*>(packet->pPresentInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSharedSwapchainsKHR : {
			auto*  packet = BitCast<packet_vkCreateSharedSwapchainsKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfos, header );
			for (uint i = 0; (packet->pCreateInfos != null) and (i < packet->swapchainCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSwapchainCreateInfoKHR*>(packet->pCreateInfos + i)), header );
			}
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSwapchains, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateWin32SurfaceKHR : {
			auto*  packet = BitCast<packet_vkCreateWin32SurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkWin32SurfaceCreateInfoKHR*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceWin32PresentationSupportKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceWin32PresentationSupportKHR*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateXlibSurfaceKHR : {
			auto*  packet = BitCast<packet_vkCreateXlibSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkXlibSurfaceCreateInfoKHR*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceXlibPresentationSupportKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceXlibPresentationSupportKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->dpy, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateXcbSurfaceKHR : {
			auto*  packet = BitCast<packet_vkCreateXcbSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkXcbSurfaceCreateInfoKHR*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceXcbPresentationSupportKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceXcbPresentationSupportKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->connection, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateAndroidSurfaceKHR : {
			auto*  packet = BitCast<packet_vkCreateAndroidSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkAndroidSurfaceCreateInfoKHR*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryWin32HandleNV : {
			auto*  packet = BitCast<packet_vkGetMemoryWin32HandleNV*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pHandle, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDescriptorUpdateTemplateKHR : {
			auto*  packet = BitCast<packet_vkCreateDescriptorUpdateTemplateKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDescriptorUpdateTemplateCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pDescriptorUpdateTemplate, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDescriptorUpdateTemplateKHR : {
			auto*  packet = BitCast<packet_vkDestroyDescriptorUpdateTemplateKHR*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkUpdateDescriptorSetWithTemplateKHR : {
			auto*  packet = BitCast<packet_vkUpdateDescriptorSetWithTemplateKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdPushDescriptorSetWithTemplateKHR : {
			auto*  packet = BitCast<packet_vkCmdPushDescriptorSetWithTemplateKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateWaylandSurfaceKHR : {
			auto*  packet = BitCast<packet_vkCreateWaylandSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkWaylandSurfaceCreateInfoKHR*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceWaylandPresentationSupportKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceWaylandPresentationSupportKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->display, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFeatures2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceFeatures2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFeatures, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceFeatures2*>(packet->pFeatures)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceProperties2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceProperties2*>(packet->pProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFormatProperties2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceFormatProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkFormatProperties2*>(packet->pFormatProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceImageFormatProperties2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceImageFormatProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImageFormatInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceImageFormatInfo2*>(packet->pImageFormatInfo)), header );
			UnpackPointer( INOUT packet->pImageFormatProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageFormatProperties2*>(packet->pImageFormatProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceQueueFamilyProperties2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceQueueFamilyProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueueFamilyPropertyCount, header );
			UnpackPointer( INOUT packet->pQueueFamilyProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkQueueFamilyProperties2*>(packet->pQueueFamilyProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceMemoryProperties2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceMemoryProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceMemoryProperties2*>(packet->pMemoryProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSparseImageFormatProperties2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSparseImageFormatProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceSparseImageFormatInfo2*>(packet->pFormatInfo)), header );
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSparseImageFormatProperties2*>(packet->pProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageMemoryRequirements2KHR : {
			auto*  packet = BitCast<packet_vkGetImageMemoryRequirements2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageMemoryRequirementsInfo2*>(packet->pInfo)), header );
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryRequirements2*>(packet->pMemoryRequirements)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetBufferMemoryRequirements2KHR : {
			auto*  packet = BitCast<packet_vkGetBufferMemoryRequirements2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBufferMemoryRequirementsInfo2*>(packet->pInfo)), header );
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryRequirements2*>(packet->pMemoryRequirements)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageSparseMemoryRequirements2KHR : {
			auto*  packet = BitCast<packet_vkGetImageSparseMemoryRequirements2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageSparseMemoryRequirementsInfo2*>(packet->pInfo)), header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirementCount, header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirements, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSparseImageMemoryRequirements2*>(packet->pSparseMemoryRequirements)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceCapabilities2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceCapabilities2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceSurfaceInfo2KHR*>(packet->pSurfaceInfo)), header );
			UnpackPointer( INOUT packet->pSurfaceCapabilities, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSurfaceCapabilities2KHR*>(packet->pSurfaceCapabilities)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceFormats2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceFormats2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceSurfaceInfo2KHR*>(packet->pSurfaceInfo)), header );
			UnpackPointer( INOUT packet->pSurfaceFormatCount, header );
			UnpackPointer( INOUT packet->pSurfaceFormats, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSurfaceFormat2KHR*>(packet->pSurfaceFormats)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceDisplayPropertiesKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceDisplayPropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkDisplayPropertiesKHR( const_cast<VkDisplayPropertiesKHR*>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceDisplayPlanePropertiesKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceDisplayPlanePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkDisplayPlanePropertiesKHR( const_cast<VkDisplayPlanePropertiesKHR*>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayModePropertiesKHR : {
			auto*  packet = BitCast<packet_vkGetDisplayModePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			Unpack_VkDisplayModePropertiesKHR( const_cast<VkDisplayModePropertiesKHR*>(packet->pProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDisplayModeKHR : {
			auto*  packet = BitCast<packet_vkCreateDisplayModeKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDisplayModeCreateInfoKHR*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pMode, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayPlaneCapabilitiesKHR : {
			auto*  packet = BitCast<packet_vkGetDisplayPlaneCapabilitiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCapabilities, header );
			Unpack_VkDisplayPlaneCapabilitiesKHR( const_cast<VkDisplayPlaneCapabilitiesKHR*>(packet->pCapabilities), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDisplayPlaneSurfaceKHR : {
			auto*  packet = BitCast<packet_vkCreateDisplayPlaneSurfaceKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDisplaySurfaceCreateInfoKHR*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pSurface, header );
			break;
		}

		case VKTRACE_TPI_VK_vkTrimCommandPoolKHR : {
			auto*  packet = BitCast<packet_vkTrimCommandPoolKHR*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalBufferPropertiesKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceExternalBufferPropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalBufferInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceExternalBufferInfo*>(packet->pExternalBufferInfo)), header );
			UnpackPointer( INOUT packet->pExternalBufferProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkExternalBufferProperties*>(packet->pExternalBufferProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryFdKHR : {
			auto*  packet = BitCast<packet_vkGetMemoryFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetFdInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryGetFdInfoKHR*>(packet->pGetFdInfo)), header );
			UnpackPointer( INOUT packet->pFd, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryFdPropertiesKHR : {
			auto*  packet = BitCast<packet_vkGetMemoryFdPropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryFdProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryFdPropertiesKHR*>(packet->pMemoryFdProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalSemaphoreInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceExternalSemaphoreInfo*>(packet->pExternalSemaphoreInfo)), header );
			UnpackPointer( INOUT packet->pExternalSemaphoreProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkExternalSemaphoreProperties*>(packet->pExternalSemaphoreProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkImportSemaphoreFdKHR : {
			auto*  packet = BitCast<packet_vkImportSemaphoreFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImportSemaphoreFdInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImportSemaphoreFdInfoKHR*>(packet->pImportSemaphoreFdInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetSemaphoreFdKHR : {
			auto*  packet = BitCast<packet_vkGetSemaphoreFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetFdInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSemaphoreGetFdInfoKHR*>(packet->pGetFdInfo)), header );
			UnpackPointer( INOUT packet->pFd, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdPushDescriptorSetKHR : {
			auto*  packet = BitCast<packet_vkCmdPushDescriptorSetKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDescriptorWrites, header );
			for (uint i = 0; (packet->pDescriptorWrites != null) and (i < packet->descriptorWriteCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkWriteDescriptorSet*>(packet->pDescriptorWrites + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkGetSwapchainStatusKHR : {
			auto*  packet = BitCast<packet_vkGetSwapchainStatusKHR*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalFencePropertiesKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceExternalFencePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalFenceInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceExternalFenceInfo*>(packet->pExternalFenceInfo)), header );
			UnpackPointer( INOUT packet->pExternalFenceProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkExternalFenceProperties*>(packet->pExternalFenceProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceGroupPeerMemoryFeaturesKHX : break;
		case VKTRACE_TPI_VK_vkBindBufferMemory2KHR : {
			auto*  packet = BitCast<packet_vkBindBufferMemory2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfos, header );
			for (uint i = 0; (packet->pBindInfos != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBindBufferMemoryInfo*>(packet->pBindInfos + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkBindImageMemory2KHR : {
			auto*  packet = BitCast<packet_vkBindImageMemory2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfos, header );
			for (uint i = 0; (packet->pBindInfos != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBindImageMemoryInfo*>(packet->pBindInfos + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDeviceMaskKHX : break;
		case VKTRACE_TPI_VK_vkGetDeviceGroupPresentCapabilitiesKHX : break;
		case VKTRACE_TPI_VK_vkGetDeviceGroupSurfacePresentModesKHX : break;
		case VKTRACE_TPI_VK_vkAcquireNextImage2KHX : break;
		case VKTRACE_TPI_VK_vkCmdDispatchBaseKHX : break;
		case VKTRACE_TPI_VK_vkGetPhysicalDevicePresentRectanglesKHX : break;
		case VKTRACE_TPI_VK_vkEnumeratePhysicalDeviceGroupsKHX : break;
		case VKTRACE_TPI_VK_vkCmdProcessCommandsNVX : {
			auto*  packet = BitCast<packet_vkCmdProcessCommandsNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pProcessCommandsInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkCmdProcessCommandsInfoNVX*>(packet->pProcessCommandsInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdReserveSpaceForCommandsNVX : {
			auto*  packet = BitCast<packet_vkCmdReserveSpaceForCommandsNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pReserveSpaceInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkCmdReserveSpaceForCommandsInfoNVX*>(packet->pReserveSpaceInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateIndirectCommandsLayoutNVX : {
			auto*  packet = BitCast<packet_vkCreateIndirectCommandsLayoutNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkIndirectCommandsLayoutCreateInfoNVX*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pIndirectCommandsLayout, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyIndirectCommandsLayoutNVX : {
			auto*  packet = BitCast<packet_vkDestroyIndirectCommandsLayoutNVX*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateObjectTableNVX : {
			auto*  packet = BitCast<packet_vkCreateObjectTableNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkObjectTableCreateInfoNVX*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pObjectTable, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyObjectTableNVX : {
			auto*  packet = BitCast<packet_vkDestroyObjectTableNVX*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkRegisterObjectsNVX : {
			auto*  packet = BitCast<packet_vkRegisterObjectsNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->ppObjectTableEntries, header );
			for (uint i = 0; (packet->ppObjectTableEntries != null) and (i < packet->objectCount); ++i) {
				UnpackPointer( INOUT packet->ppObjectTableEntries[i], header );
					Unpack_VkObjectTableEntryNVX( const_cast<VkObjectTableEntryNVX*>(packet->ppObjectTableEntries[i]), header );
			}
			UnpackPointer( INOUT packet->pObjectIndices, header );
			break;
		}

		case VKTRACE_TPI_VK_vkUnregisterObjectsNVX : {
			auto*  packet = BitCast<packet_vkUnregisterObjectsNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pObjectEntryTypes, header );
			UnpackPointer( INOUT packet->pObjectIndices, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFeatures, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDeviceGeneratedCommandsFeaturesNVX*>(packet->pFeatures)), header );
			UnpackPointer( INOUT packet->pLimits, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDeviceGeneratedCommandsLimitsNVX*>(packet->pLimits)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetViewportWScalingNV : {
			auto*  packet = BitCast<packet_vkCmdSetViewportWScalingNV*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pViewportWScalings, header );
			for (uint i = 0; (packet->pViewportWScalings != null) and (i < packet->viewportCount); ++i) {
				Unpack_VkViewportWScalingNV( const_cast<VkViewportWScalingNV*>(packet->pViewportWScalings + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkReleaseDisplayEXT : {
			auto*  packet = BitCast<packet_vkReleaseDisplayEXT*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSurfaceCapabilities2EXT : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSurfaceCapabilities2EXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSurfaceCapabilities, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSurfaceCapabilities2EXT*>(packet->pSurfaceCapabilities)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetRefreshCycleDurationGOOGLE : {
			auto*  packet = BitCast<packet_vkGetRefreshCycleDurationGOOGLE*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayTimingProperties, header );
			Unpack_VkRefreshCycleDurationGOOGLE( const_cast<VkRefreshCycleDurationGOOGLE*>(packet->pDisplayTimingProperties), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPastPresentationTimingGOOGLE : {
			auto*  packet = BitCast<packet_vkGetPastPresentationTimingGOOGLE*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPresentationTimingCount, header );
			UnpackPointer( INOUT packet->pPresentationTimings, header );
			Unpack_VkPastPresentationTimingGOOGLE( const_cast<VkPastPresentationTimingGOOGLE*>(packet->pPresentationTimings), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDiscardRectangleEXT : {
			auto*  packet = BitCast<packet_vkCmdSetDiscardRectangleEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDiscardRectangles, header );
			for (uint i = 0; (packet->pDiscardRectangles != null) and (i < packet->discardRectangleCount); ++i) {
				Unpack_VkRect2D( const_cast<VkRect2D*>(packet->pDiscardRectangles + i), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkSetHdrMetadataEXT : {
			auto*  packet = BitCast<packet_vkSetHdrMetadataEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSwapchains, header );
			UnpackPointer( INOUT packet->pMetadata, header );
			for (uint i = 0; (packet->pMetadata != null) and (i < packet->swapchainCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkHdrMetadataEXT*>(packet->pMetadata + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkAcquireXlibDisplayEXT : {
			auto*  packet = BitCast<packet_vkAcquireXlibDisplayEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->dpy, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetRandROutputDisplayEXT : {
			auto*  packet = BitCast<packet_vkGetRandROutputDisplayEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->dpy, header );
			UnpackPointer( INOUT packet->pDisplay, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDisplayPowerControlEXT : {
			auto*  packet = BitCast<packet_vkDisplayPowerControlEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayPowerInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDisplayPowerInfoEXT*>(packet->pDisplayPowerInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkRegisterDeviceEventEXT : {
			auto*  packet = BitCast<packet_vkRegisterDeviceEventEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDeviceEventInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDeviceEventInfoEXT*>(packet->pDeviceEventInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pFence, header );
			break;
		}

		case VKTRACE_TPI_VK_vkRegisterDisplayEventEXT : {
			auto*  packet = BitCast<packet_vkRegisterDisplayEventEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayEventInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDisplayEventInfoEXT*>(packet->pDisplayEventInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pFence, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetSwapchainCounterEXT : {
			auto*  packet = BitCast<packet_vkGetSwapchainCounterEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCounterValue, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetSampleLocationsEXT : {
			auto*  packet = BitCast<packet_vkCmdSetSampleLocationsEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSampleLocationsInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSampleLocationsInfoEXT*>(packet->pSampleLocationsInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceMultisamplePropertiesEXT : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceMultisamplePropertiesEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMultisampleProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMultisamplePropertiesEXT*>(packet->pMultisampleProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSamplerYcbcrConversionKHR : {
			auto*  packet = BitCast<packet_vkCreateSamplerYcbcrConversionKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSamplerYcbcrConversionCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pYcbcrConversion, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySamplerYcbcrConversionKHR : {
			auto*  packet = BitCast<packet_vkDestroySamplerYcbcrConversionKHR*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayPlaneSupportedDisplaysKHR : {
			auto*  packet = BitCast<packet_vkGetDisplayPlaneSupportedDisplaysKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayCount, header );
			UnpackPointer( INOUT packet->pDisplays, header );
			break;
		}

		case VKTRACE_TPI_VK_vkImportFenceFdKHR : {
			auto*  packet = BitCast<packet_vkImportFenceFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImportFenceFdInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImportFenceFdInfoKHR*>(packet->pImportFenceFdInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetFenceFdKHR : {
			auto*  packet = BitCast<packet_vkGetFenceFdKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetFdInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkFenceGetFdInfoKHR*>(packet->pGetFdInfo)), header );
			UnpackPointer( INOUT packet->pFd, header );
			break;
		}

		case VKTRACE_TPI_VK_vkImportFenceWin32HandleKHR : {
			auto*  packet = BitCast<packet_vkImportFenceWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImportFenceWin32HandleInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImportFenceWin32HandleInfoKHR*>(packet->pImportFenceWin32HandleInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetFenceWin32HandleKHR : {
			auto*  packet = BitCast<packet_vkGetFenceWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetWin32HandleInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkFenceGetWin32HandleInfoKHR*>(packet->pGetWin32HandleInfo)), header );
			UnpackPointer( INOUT packet->pHandle, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryWin32HandleKHR : {
			auto*  packet = BitCast<packet_vkGetMemoryWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetWin32HandleInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryGetWin32HandleInfoKHR*>(packet->pGetWin32HandleInfo)), header );
			UnpackPointer( INOUT packet->pHandle, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryWin32HandlePropertiesKHR : {
			auto*  packet = BitCast<packet_vkGetMemoryWin32HandlePropertiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryWin32HandleProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryWin32HandlePropertiesKHR*>(packet->pMemoryWin32HandleProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkImportSemaphoreWin32HandleKHR : {
			auto*  packet = BitCast<packet_vkImportSemaphoreWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImportSemaphoreWin32HandleInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImportSemaphoreWin32HandleInfoKHR*>(packet->pImportSemaphoreWin32HandleInfo)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetSemaphoreWin32HandleKHR : {
			auto*  packet = BitCast<packet_vkGetSemaphoreWin32HandleKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pGetWin32HandleInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSemaphoreGetWin32HandleInfoKHR*>(packet->pGetWin32HandleInfo)), header );
			UnpackPointer( INOUT packet->pHandle, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetMemoryHostPointerPropertiesEXT : {
			auto*  packet = BitCast<packet_vkGetMemoryHostPointerPropertiesEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pHostPointer, header );
			UnpackPointer( INOUT packet->pMemoryHostPointerProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryHostPointerPropertiesEXT*>(packet->pMemoryHostPointerProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkCreateValidationCacheEXT : {
			auto*  packet = BitCast<packet_vkCreateValidationCacheEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkValidationCacheCreateInfoEXT*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pValidationCache, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyValidationCacheEXT : {
			auto*  packet = BitCast<packet_vkDestroyValidationCacheEXT*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkMergeValidationCachesEXT : {
			auto*  packet = BitCast<packet_vkMergeValidationCachesEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pSrcCaches, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetValidationCacheDataEXT : {
			auto*  packet = BitCast<packet_vkGetValidationCacheDataEXT*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDataSize, header );
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetShaderInfoAMD : {
			auto*  packet = BitCast<packet_vkGetShaderInfoAMD*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfoSize, header );
			UnpackPointer( INOUT packet->pInfo, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceQueue2 : {
			auto*  packet = BitCast<packet_vkGetDeviceQueue2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueueInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDeviceQueueInfo2*>(packet->pQueueInfo)), header );
			UnpackPointer( INOUT packet->pQueue, header );
			break;
		}

		case VKTRACE_TPI_VK_vkEnumerateInstanceVersion : break;
		case VKTRACE_TPI_VK_vkGetDescriptorSetLayoutSupport : {
			auto*  packet = BitCast<packet_vkGetDescriptorSetLayoutSupport*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDescriptorSetLayoutCreateInfo*>(packet->pCreateInfo)), header );
			UnpackPointer( INOUT packet->pSupport, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDescriptorSetLayoutSupport*>(packet->pSupport)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceGroupPresentCapabilitiesKHR : {
			auto*  packet = BitCast<packet_vkGetDeviceGroupPresentCapabilitiesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDeviceGroupPresentCapabilities, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDeviceGroupPresentCapabilitiesKHR*>(packet->pDeviceGroupPresentCapabilities)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceGroupSurfacePresentModesKHR : {
			auto*  packet = BitCast<packet_vkGetDeviceGroupSurfacePresentModesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pModes, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDevicePresentRectanglesKHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDevicePresentRectanglesKHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pRectCount, header );
			UnpackPointer( INOUT packet->pRects, header );
			Unpack_VkRect2D( const_cast<VkRect2D*>(packet->pRects), header );
			break;
		}

		case VKTRACE_TPI_VK_vkAcquireNextImage2KHR : {
			auto*  packet = BitCast<packet_vkAcquireNextImage2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pAcquireInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkAcquireNextImageInfoKHR*>(packet->pAcquireInfo)), header );
			UnpackPointer( INOUT packet->pImageIndex, header );
			break;
		}

		case VKTRACE_TPI_VK_vkBindBufferMemory2 : {
			auto*  packet = BitCast<packet_vkBindBufferMemory2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfos, header );
			for (uint i = 0; (packet->pBindInfos != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBindBufferMemoryInfo*>(packet->pBindInfos + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkBindImageMemory2 : {
			auto*  packet = BitCast<packet_vkBindImageMemory2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pBindInfos, header );
			for (uint i = 0; (packet->pBindInfos != null) and (i < packet->bindInfoCount); ++i) {
				UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBindImageMemoryInfo*>(packet->pBindInfos + i)), header );
			}
			break;
		}

		case VKTRACE_TPI_VK_vkGetDeviceGroupPeerMemoryFeatures : {
			auto*  packet = BitCast<packet_vkGetDeviceGroupPeerMemoryFeatures*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPeerMemoryFeatures, header );
			break;
		}

		case VKTRACE_TPI_VK_vkCmdSetDeviceMask : {
			auto*  packet = BitCast<packet_vkCmdSetDeviceMask*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCmdDispatchBase : {
			auto*  packet = BitCast<packet_vkCmdDispatchBase*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkEnumeratePhysicalDeviceGroups : {
			auto*  packet = BitCast<packet_vkEnumeratePhysicalDeviceGroups*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPhysicalDeviceGroupCount, header );
			UnpackPointer( INOUT packet->pPhysicalDeviceGroupProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceGroupProperties*>(packet->pPhysicalDeviceGroupProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageMemoryRequirements2 : {
			auto*  packet = BitCast<packet_vkGetImageMemoryRequirements2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageMemoryRequirementsInfo2*>(packet->pInfo)), header );
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryRequirements2*>(packet->pMemoryRequirements)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetBufferMemoryRequirements2 : {
			auto*  packet = BitCast<packet_vkGetBufferMemoryRequirements2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkBufferMemoryRequirementsInfo2*>(packet->pInfo)), header );
			UnpackPointer( INOUT packet->pMemoryRequirements, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkMemoryRequirements2*>(packet->pMemoryRequirements)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetImageSparseMemoryRequirements2 : {
			auto*  packet = BitCast<packet_vkGetImageSparseMemoryRequirements2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageSparseMemoryRequirementsInfo2*>(packet->pInfo)), header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirementCount, header );
			UnpackPointer( INOUT packet->pSparseMemoryRequirements, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSparseImageMemoryRequirements2*>(packet->pSparseMemoryRequirements)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFeatures2 : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceFeatures2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFeatures, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceFeatures2*>(packet->pFeatures)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceProperties2 : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceProperties2*>(packet->pProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceFormatProperties2 : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceFormatProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkFormatProperties2*>(packet->pFormatProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceImageFormatProperties2 : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceImageFormatProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pImageFormatInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceImageFormatInfo2*>(packet->pImageFormatInfo)), header );
			UnpackPointer( INOUT packet->pImageFormatProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkImageFormatProperties2*>(packet->pImageFormatProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceQueueFamilyProperties2 : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceQueueFamilyProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pQueueFamilyPropertyCount, header );
			UnpackPointer( INOUT packet->pQueueFamilyProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkQueueFamilyProperties2*>(packet->pQueueFamilyProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceMemoryProperties2 : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceMemoryProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pMemoryProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceMemoryProperties2*>(packet->pMemoryProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceSparseImageFormatProperties2 : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceSparseImageFormatProperties2*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pFormatInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceSparseImageFormatInfo2*>(packet->pFormatInfo)), header );
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSparseImageFormatProperties2*>(packet->pProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkTrimCommandPool : {
			auto*  packet = BitCast<packet_vkTrimCommandPool*>(header->pBody);
			packet->header = header;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateSamplerYcbcrConversion : {
			auto*  packet = BitCast<packet_vkCreateSamplerYcbcrConversion*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkSamplerYcbcrConversionCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pYcbcrConversion, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroySamplerYcbcrConversion : {
			auto*  packet = BitCast<packet_vkDestroySamplerYcbcrConversion*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkCreateDescriptorUpdateTemplate : {
			auto*  packet = BitCast<packet_vkCreateDescriptorUpdateTemplate*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pCreateInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDescriptorUpdateTemplateCreateInfo*>(packet->pCreateInfo)), header );
			packet->pAllocator = null;
			UnpackPointer( INOUT packet->pDescriptorUpdateTemplate, header );
			break;
		}

		case VKTRACE_TPI_VK_vkDestroyDescriptorUpdateTemplate : {
			auto*  packet = BitCast<packet_vkDestroyDescriptorUpdateTemplate*>(header->pBody);
			packet->header = header;
			packet->pAllocator = null;
			break;
		}

		case VKTRACE_TPI_VK_vkUpdateDescriptorSetWithTemplate : {
			auto*  packet = BitCast<packet_vkUpdateDescriptorSetWithTemplate*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pData, header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalBufferProperties : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceExternalBufferProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalBufferInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceExternalBufferInfo*>(packet->pExternalBufferInfo)), header );
			UnpackPointer( INOUT packet->pExternalBufferProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkExternalBufferProperties*>(packet->pExternalBufferProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalFenceProperties : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceExternalFenceProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalFenceInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceExternalFenceInfo*>(packet->pExternalFenceInfo)), header );
			UnpackPointer( INOUT packet->pExternalFenceProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkExternalFenceProperties*>(packet->pExternalFenceProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceExternalSemaphoreProperties : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceExternalSemaphoreProperties*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pExternalSemaphoreInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkPhysicalDeviceExternalSemaphoreInfo*>(packet->pExternalSemaphoreInfo)), header );
			UnpackPointer( INOUT packet->pExternalSemaphoreProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkExternalSemaphoreProperties*>(packet->pExternalSemaphoreProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceDisplayProperties2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceDisplayProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDisplayProperties2KHR*>(packet->pProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetPhysicalDeviceDisplayPlaneProperties2KHR : {
			auto*  packet = BitCast<packet_vkGetPhysicalDeviceDisplayPlaneProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDisplayPlaneProperties2KHR*>(packet->pProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayModeProperties2KHR : {
			auto*  packet = BitCast<packet_vkGetDisplayModeProperties2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pPropertyCount, header );
			UnpackPointer( INOUT packet->pProperties, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDisplayModeProperties2KHR*>(packet->pProperties)), header );
			break;
		}

		case VKTRACE_TPI_VK_vkGetDisplayPlaneCapabilities2KHR : {
			auto*  packet = BitCast<packet_vkGetDisplayPlaneCapabilities2KHR*>(header->pBody);
			packet->header = header;
			UnpackPointer( INOUT packet->pDisplayPlaneInfo, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDisplayPlaneInfo2KHR*>(packet->pDisplayPlaneInfo)), header );
			UnpackPointer( INOUT packet->pCapabilities, header );
			UnpackStruct( BitCast<VkBaseOutStructure*>(const_cast<VkDisplayPlaneCapabilities2KHR*>(packet->pCapabilities)), header );
			break;
		}

	}
	DISABLE_ENUM_CHECKS();
}

